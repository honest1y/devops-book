{"./":{"url":"./","title":"序言","keywords":"","body":"Docker Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Rancher Rancher是一套容器管理平台，它可以帮助组织在生产环境中轻松快捷的部署和管理容器。 Rancher可以轻松地管理各种环境的Kubernetes，满足IT需求并为DevOps团队提供支持。 Kubernetes不仅已经成为的容器编排标准，它也正在迅速成为各类云和虚拟化厂商提供的标准基础架构。Rancher用户可以选择使用Rancher Kubernetes Engine(RKE)创建Kubernetes集群，也可以使用GKE，AKS和EKS等云Kubernetes服务。 Rancher用户还可以导入和管理现有的Kubernetes集群。 Rancher支持各类集中式身份验证系统来管理Kubernetes集群。例如，大型企业的员工可以使用其公司Active Directory凭证访问GKE中的Kubernetes集群。IT管理员可以在用户，组，项目，集群和云中设置访问控制和安全策略。 IT管理员可以在单个页面对所有Kubernetes集群的健康状况和容量进行监控。 Rancher为DevOps工程师提供了一个直观的用户界面来管理他们的服务容器，用户不需要深入了解Kubernetes概念就可以开始使用Rancher。 Rancher包含应用商店，支持一键式部署Helm和Compose模板。Rancher通过各种云、本地生态系统产品认证，其中包括安全工具，监控系统，容器仓库以及存储和网络驱动程序。下图说明了Rancher在IT和DevOps组织中扮演的角色。每个团队都会在他们选择的公共云或私有云上部署应用程序。 Kubernetes Kubernetes 是 Google 团队发起的开源项目，它的目标是管理跨多个主机的容器，提供基本的部署，维护以及运用伸缩，主要实现语言为 Go 语言。Kubernetes 是： 易学：轻量级，简单，容易理解 便携：支持公有云，私有云，混合云，以及多种云平台 可拓展：模块化，可插拔，支持钩子，可任意组合 自修复：自动重调度，自动重启，自动复制 Kubernetes 构建于 Google 数十年经验，一大半来源于 Google 生产环境规模的经验。结合了社区最佳的想法和实践。 在分布式系统中，部署，调度，伸缩一直是最为重要的也最为基础的功能。Kubernetes 就是希望解决这一序列问题的。 Kubernetes 目前在GitHub进行维护。 Shell Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。 powered by Gitbook该文件最后修改时间： 2020-04-01 16:07:42 "},"article/Docker/docker.html":{"url":"article/Docker/docker.html","title":"1、Docker介绍","keywords":"","body":"Docker Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 powered by Gitbook该文件最后修改时间： 2020-03-25 14:13:40 "},"article/Docker/Chapter2/2-1-image.html":{"url":"article/Docker/Chapter2/2-1-image.html","title":"2.1 镜像","keywords":"","body":"Docker 镜像 我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 分层存储 因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。 镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。 分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。 关于镜像构建，将会在后续相关章节中做进一步的讲解。 powered by Gitbook该文件最后修改时间： 2020-03-25 14:30:37 "},"article/Docker/Chapter2/2-2-containor.html":{"url":"article/Docker/Chapter2/2-2-containor.html","title":"2.2 容器","keywords":"","body":"Docker 容器 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。 前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。Docker 容器 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。 前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。Docker 容器 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。 前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 powered by Gitbook该文件最后修改时间： 2020-03-25 14:30:50 "},"article/Docker/Chapter2/2-3-repository.html":{"url":"article/Docker/Chapter2/2-3-repository.html","title":"2.3 仓库","keywords":"","body":"Docker Registry 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 : 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。 仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。 Docker Registry 公开服务 Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。 最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。 由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。 国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。 私有 Docker Registry 除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。在 私有仓库 一节中，会有进一步的搭建私有 Registry 服务的讲解。 开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。 powered by Gitbook该文件最后修改时间： 2020-03-25 14:31:02 "},"article/Docker/Chapter3/3-1-install.html":{"url":"article/Docker/Chapter3/3-1-install.html","title":"3.1 Centos","keywords":"","body":"安装 step 1: 安装必要的一些系统工具 $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 Step 2: 添加软件源信息 $ sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo Step 3: 更新并安装 Docker-CE sudo yum makecache fast sudo yum -y install docker-ce Step 4: 开启Docker服务 $ sudo systemctl enable docker $ sudo systemctl start docker Step 5: 安装校验 [root@dts-test ~]# docker version Client: Docker Engine - Community Version: 19.03.2 API version: 1.40 Go version: go1.12.8 Git commit: 6a30dfc Built: Thu Aug 29 05:28:55 2019 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.2 API version: 1.40 (minimum version 1.12) Go version: go1.12.8 Git commit: 6a30dfc Built: Thu Aug 29 05:27:34 2019 OS/Arch: linux/amd64 Experimental: false 配置加速器 针对Docker客户端版本大于 1.10.0 的用户 可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json powered by Gitbook该文件最后修改时间： 2020-03-30 15:07:18 "},"article/Docker/Chapter4/4-1-get-image.html":{"url":"article/Docker/Chapter4/4-1-get-image.html","title":"4.1 获取镜像","keywords":"","body":"获取镜像 之前提到过，Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。 从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为： docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。 Docker 镜像仓库地址：地址的格式一般是 [:端口号]。默认地址是 Docker Hub。 仓库名：如之前所说，这里的仓库名是两段式名称，即 /。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 比如： $ docker pull ubuntu:18.04 18.04: Pulling from library/ubuntu bf5d46315322: Pull complete 9f13e0ac480c: Pull complete e8988b5b3097: Pull complete 40af181810e7: Pull complete e6f7c7e5c03e: Pull complete Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe Status: Downloaded newer image for ubuntu:18.04 上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:18.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。 从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。 在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 sha256 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。 如果从 Docker Hub 下载镜像非常缓慢，可以参照 镜像加速器 一节配置加速器。 运行 有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:18.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。 $ docker run -it --rm \\ ubuntu:18.04 \\ bash root@e7009c6ce357:/# cat /etc/os-release NAME=\"Ubuntu\" VERSION=\"18.04.1 LTS (Bionic Beaver)\" ID=ubuntu ID_LIKE=debian PRETTY_NAME=\"Ubuntu 18.04.1 LTS\" VERSION_ID=\"18.04\" HOME_URL=\"https://www.ubuntu.com/\" SUPPORT_URL=\"https://help.ubuntu.com/\" BUG_REPORT_URL=\"https://bugs.launchpad.net/ubuntu/\" PRIVACY_POLICY_URL=\"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\" VERSION_CODENAME=bionic UBUNTU_CODENAME=bionic docker run 就是运行容器的命令，具体格式我们会在容器一节进行详细讲解，我们这里简要的说明一下上面用到的参数。 -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。 bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 18.04.1 LTS 系统。 最后我们通过 exit 退出了这个容器。 powered by Gitbook该文件最后修改时间： 2020-03-25 14:43:44 "},"article/Docker/Chapter4/4-2-list-image.html":{"url":"article/Docker/Chapter4/4-2-list-image.html","title":"4.2 列出镜像","keywords":"","body":"列出镜像 要想列出已经下载下来的镜像，可以使用 docker images 命令。 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE node latest 7354979df4ec 2 months ago 939MB redis 4.0 8280a2c45ce5 4 months ago 89.2MB centos 7 5e35e350aded 4 months ago 203MB alpine latest 965ea09ff2eb 5 months ago 5.55MB centos latest 0f3e07c0138f 5 months ago 220MB redis 3.2.12 87856cc39862 17 months ago 76MB 00285df0df87 5 days ago 342 MB 列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。 镜像体积 如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，ubuntu:18.04 镜像大小，在这里是 127 MB，但是在 Docker Hub 显示的却是 50 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。 另外一个需要注意的问题是，docker images 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。 你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。 $ docker system df TYPE TOTAL ACTIVE SIZE RECLAIMABLE Images 6 2 1.532GB 1.236GB (80%) Containers 4 2 1.116GB 673.6MB (60%) Local Volumes 2 1 10.27MB 93B (0%) Build Cache 0 0 0B 0B 虚悬镜像 上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 。： 00285df0df87 5 days ago 342 MB 这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像： $ docker image ls -f dangling=true REPOSITORY TAG IMAGE ID CREATED SIZE 00285df0df87 5 days ago 342 MB 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。 $ docker image prune 中间层镜像 为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。 $ docker image ls -a 这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。 列出部分镜像 不加任何参数的情况下，docker images 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。docker images 有好几个参数可以帮助做到这个事情。 根据仓库名列出镜像 $ docker images centos REPOSITORY TAG IMAGE ID CREATED SIZE centos 7 5e35e350aded 4 months ago 203MB centos latest 0f3e07c0138f 5 months ago 220MB 列出特定的某个镜像，也就是说指定仓库名和标签 docker images centos:7 REPOSITORY TAG IMAGE ID CREATED SIZE centos 7 5e35e350aded 4 months ago 203MB 以特定格式显示 默认情况下，docker images 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 docker images 把所有的虚悬镜像的 ID 列出来，然后才可以交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数。 $ docker images -q 7354979df4ec 8280a2c45ce5 5e35e350aded 965ea09ff2eb 0f3e07c0138f 87856cc39862 --filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。 另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。 比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名： $ docker image ls --format \"{{.ID}}: {{.Repository}}\" 7354979df4ec: node 8280a2c45ce5: redis 5e35e350aded: centos 965ea09ff2eb: alpine 0f3e07c0138f: centos 87856cc39862: redis 或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列： $ docker image ls --format \"table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}\" IMAGE ID REPOSITORY TAG 7354979df4ec node latest 8280a2c45ce5 redis 4.0 5e35e350aded centos 7 965ea09ff2eb alpine latest 0f3e07c0138f centos latest 87856cc39862 redis 3.2.12 powered by Gitbook该文件最后修改时间： 2020-03-25 15:09:29 "},"article/Docker/Chapter4/4-3-delete-image.html":{"url":"article/Docker/Chapter4/4-3-delete-image.html","title":"4.3 删除本地镜像","keywords":"","body":"删除本地镜像 如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为： $ docker image rm [选项] [ ...] 用 ID、镜像名、摘要删除镜像 其中， 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。 比如我们有这么一些镜像： $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE node latest 7354979df4ec 2 months ago 939MB redis 4.0 8280a2c45ce5 4 months ago 89.2MB centos 7 5e35e350aded 4 months ago 203MB alpine latest 965ea09ff2eb 5 months ago 5.55MB centos latest 0f3e07c0138f 5 months ago 220MB redis 3.2.12 87856cc39862 17 months ago 76MB 我们可以用镜像的完整 ID，也称为 长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 短 ID 来删除镜像。docker image ls 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。 比如这里，如果我们要删除 redis:alpine 镜像，可以执行： $ docker image rm alpine Untagged: alpine:latest Untagged: alpine@sha256:c19173c5ada610a5989151111163d28a67368362762534d8a8121ce95cf2bd5a Deleted: sha256:965ea09ff2ebd2b9eeec88cd822ce156f6674c7e99be082c7efac3c62f3ff652 Deleted: sha256:77cae8ab23bf486355d1b3191259705374f4a11d483b24964d2f729dd8c076a0 我们也可以用镜像名，也就是 :，来删除镜像。 $ docker image rm centos Untagged: centos:latest Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38 当然，更精确的是使用 镜像摘要 删除镜像。 $ docker image ls --digests REPOSITORY TAG DIGEST IMAGE ID CREATED SIZE node slim sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 6e0c4c8e3913 3 weeks ago 214 MB $ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 Untagged 和 Deleted 如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 Untagged，另一类是 Deleted。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。 因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。 当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不一样的原因。 除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。 用 docker image ls 命令来配合 像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用 docker image rm，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。 比如，我们需要删除所有仓库名为 redis 的镜像： $ docker image rm $(docker image ls -q redis) 或者删除所有在 mongo:3.2 之前的镜像： $ docker image rm $(docker image ls -q -f before=mongo:3.2) 充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。 powered by Gitbook该文件最后修改时间： 2020-03-25 15:18:41 "},"article/Docker/Chapter4/4-4-commit-image.html":{"url":"article/Docker/Chapter4/4-4-commit-image.html","title":"4.4 commit 修改镜像","keywords":"","body":"commit 修改镜像 镜像是容器的基础，每次执行 docker run 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。接下来的几节就将讲解如何定制镜像。 回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。 现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。 $ docker run --name webserver -d -p 80:80 nginx 这条命令会用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器。 如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker Desktop for Mac/Windows，那么可以直接访问：http://localhost；如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 localhost 换为虚拟机地址或者实际云服务器地址。 直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。 现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 docker exec 命令进入容器，修改其内容。 $ docker exec -it webserver bash root@3729b97e8226:/# echo 'Hello, Docker!' > /usr/share/nginx/html/index.html root@3729b97e8226:/# exit exit 我们以交互式终端方式进入 webserver 容器，并执行了 bash 命令，也就是获得一个可操作的 Shell。 然后，我们用 Hello, Docker! 覆盖了 /usr/share/nginx/html/index.html 的内容。 现在我们再刷新浏览器的话，会发现内容被改变了。 我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 docker diff 命令看到具体的改动。 $ docker diff webserver C /root A /root/.bash_history C /run C /usr C /usr/share C /usr/share/nginx C /usr/share/nginx/html C /usr/share/nginx/html/index.html C /var C /var/cache C /var/cache/nginx A /var/cache/nginx/client_temp A /var/cache/nginx/fastcgi_temp A /var/cache/nginx/proxy_temp A /var/cache/nginx/scgi_temp A /var/cache/nginx/uwsgi_temp 现在我们定制好了变化，我们希望能将其保存下来形成镜像。 要知道，当运行一个容器的时候（如果不使用卷的话），做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后运行这个新镜像的时候，就会拥有原有容器最后的文件变化。 docker commit 的语法格式为： docker commit [选项] [[:]] 可以用下面的命令将容器保存为镜像： $ docker commit \\ --author \"Tao Wang \" \\ --message \"修改了默认网页\" \\ webserver \\ nginx:v2 sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214 其中 --author 是指定修改的作者，而 --message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。 可以在 docker image ls 中看到这个新定制的镜像： $ docker image ls nginx REPOSITORY TAG IMAGE ID CREATED SIZE nginx v2 07e334659748 9 seconds ago 181.5 MB nginx 1.11 05a60462f8ba 12 days ago 181.5 MB nginx latest e43d811ce2f4 4 weeks ago 181.5 MB 还可以用 docker history 具体查看镜像内的历史记录，如果比较 nginx:latest 的历史记录，我们会发现新增了我们刚刚提交的这一层。 $ docker history nginx:v2 IMAGE CREATED CREATED BY SIZE COMMENT 07e334659748 54 seconds ago nginx -g daemon off; 95 B 修改了默认网页 e43d811ce2f4 4 weeks ago /bin/sh -c #(nop) CMD [\"nginx\" \"-g\" \"daemon 0 B 4 weeks ago /bin/sh -c #(nop) EXPOSE 443/tcp 80/tcp 0 B 4 weeks ago /bin/sh -c ln -sf /dev/stdout /var/log/nginx/ 22 B 4 weeks ago /bin/sh -c apt-key adv --keyserver hkp://pgp. 58.46 MB 4 weeks ago /bin/sh -c #(nop) ENV NGINX_VERSION=1.11.5-1 0 B 4 weeks ago /bin/sh -c #(nop) MAINTAINER NGINX Docker Ma 0 B 4 weeks ago /bin/sh -c #(nop) CMD [\"/bin/bash\"] 0 B 4 weeks ago /bin/sh -c #(nop) ADD file:23aa4f893e3288698c 123 MB 新的镜像定制好后，我们可以来运行这个镜像。 docker run --name web2 -d -p 81:80 nginx:v2 这里我们命名为新的服务为 web2，并且映射到 81 端口。如果是 Docker Desktop for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 http://localhost:81 看到结果，其内容应该和之前修改后的 webserver 一样。 至此，我们第一次完成了定制镜像，使用的是 docker commit 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。 慎用 docker commit 使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。 首先，如果仔细观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 /usr/share/nginx/html/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。 此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。 而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。 powered by Gitbook该文件最后修改时间： 2020-03-30 17:52:09 "},"article/Docker/Chapter5/5-1-from.html":{"url":"article/Docker/Chapter5/5-1-from.html","title":"5.1 FROM 指定基础镜像","keywords":"","body":"FROM 指定基础镜像 镜像的定制实际上就是定制每一层所添加的配置、文件。如果可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。 Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。 在一个空白目录中，建立一个文本文件，并命名为 Dockerfile： $ mkdir mynginx $ cd mynginx $ touch Dockerfile 其内容为： FROM nginx RUN echo 'Hello, Docker!' > /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。 FROM 指定基础镜像 所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 在 Docker Hub 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-2-run.html":{"url":"article/Docker/Chapter5/5-2-run.html","title":"5.2 RUN 执行命令","keywords":"","body":"RUN 执行命令 RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式：RUN ，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 RUN echo 'Hello, Docker!' > /usr/share/nginx/html/index.html exec 格式：RUN [\"可执行文件\", \"参数1\", \"参数2\"]，这更像是函数调用中的格式。 既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样： FROM debian:stretch RUN apt-get update RUN apt-get install -y gcc libc6-dev make wget RUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" RUN mkdir -p /usr/src/redis RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 RUN make -C /usr/src/redis RUN make -C /usr/src/redis install 之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。 而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。 $\\color{red}{Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。}$ 上面的 Dockerfile 正确的写法应该是这样： FROM debian:stretch RUN buildDeps='gcc libc6-dev make wget' \\ && apt-get update \\ && apt-get install -y $buildDeps \\ && wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" \\ && mkdir -p /usr/src/redis \\ && tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ && make -C /usr/src/redis \\ && make -C /usr/src/redis install \\ && rm -rf /var/lib/apt/lists/* \\ && rm redis.tar.gz \\ && rm -r /usr/src/redis \\ && apt-get purge -y --auto-remove $buildDeps 首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 && 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。 并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。 此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。 powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-3-build.html":{"url":"article/Docker/Chapter5/5-3-build.html","title":"5.3 构建镜像","keywords":"","body":"构建镜像 在 Dockerfile 文件所在目录执行： $ docker build -t nginx:v3 . Sending build context to Docker daemon 2.048 kB Step 1 : FROM nginx ---> e43d811ce2f4 Step 2 : RUN echo 'Hello, Docker!' > /usr/share/nginx/html/index.html ---> Running in 9cdc27646c7b ---> 44aa4490ce2c Removing intermediate container 9cdc27646c7b Successfully built 44aa4490ce2c 从命令的输出结果中，可以清晰的看到镜像的构建过程。在 Step 2 中，如同之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。 这里我们使用了 docker build 命令进行镜像构建。其格式为： docker build [选项] 在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。 powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-4-context.html":{"url":"article/Docker/Chapter5/5-4-context.html","title":"5.4 镜像构建上下文（Context）","keywords":"","body":"镜像构建上下文（Context） 如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？ 首先要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。 当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？ 这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。 如果在 Dockerfile 中这么写： COPY ./package.json /app/ 这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。 因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。 现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。 如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程： $ docker build -t nginx:v3 . Sending build context to Docker daemon 2.048 kB ... 理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。 这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。 当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。 powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-5-copy.html":{"url":"article/Docker/Chapter5/5-5-copy.html","title":"5.5 COPY 复制文件","keywords":"","body":"COPY 复制文件 1、格式 COPY [--chown=:] ... COPY [--chown=:] [\"\",... \"\"] 和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。 COPY 指令将从构建上下文目录中 的文件/目录复制到新的一层的镜像内的 位置。比如： COPY package.json /usr/src/app/ 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如： COPY hom* /mydir/ COPY hom?.txt /mydir/ 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 在使用该指令的时候还可以加上 --chown=: 选项来改变文件的所属用户及所属组。 COPY --chown=55:mygroup files* /mydir/ COPY --chown=bin files* /mydir/ COPY --chown=1 files* /mydir/ COPY --chown=10:11 files* /mydir/ powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-6-add.html":{"url":"article/Docker/Chapter5/5-6-add.html","title":"5.6 ADD 高级复制文件","keywords":"","body":"ADD 更高级的复制文件 ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。 可以是一个 URL 这种情况下，Docker 引擎会试图去下载这个链接的文件放到 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。 可以是 tar 压缩文件 压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 去。 在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中： FROM scratch ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz / ... 但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。 在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。 另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。 因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。 在使用该指令的时候还可以加上 --chown=: 选项来改变文件的所属用户及所属组。 ADD --chown=55:mygroup files* /mydir/ ADD --chown=bin files* /mydir/ ADD --chown=1 files* /mydir/ ADD --chown=10:11 files* /mydir/ powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-7-cmd.html":{"url":"article/Docker/Chapter5/5-7-cmd.html","title":"5.7 CMD 容器启动命令","keywords":"","body":"CMD 容器启动命令 1、格式 shell 格式：CMD exec 格式：CMD [\"可执行文件\", \"参数1\", \"参数2\"...] 参数列表格式：CMD [\"参数1\", \"参数2\"...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 2、作用 Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 \"，而不要使用单引号。 如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如： CMD echo $HOME 在实际执行中，会将其变更为： CMD [ \"sh\", \"-c\", \"echo $HOME\" ] 这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。 提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。 Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。 一些初学者将 CMD 写为： CMD service nginx start 然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ \"sh\", \"-c\", \"service nginx start\"]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。 正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如： CMD [\"nginx\", \"-g\", \"daemon off;\"] powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:39 "},"article/Docker/Chapter5/5-8-entrypoint.html":{"url":"article/Docker/Chapter5/5-8-entrypoint.html","title":"5.8 ENTRYPOINT 入口点","keywords":"","body":"ENTRYPOINT 入口点 1、格式 和RUN 指令格式一样，分为 exec 格式和 shell 格式。 2、作用 指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为： \"\" 那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 \"\" 有什么好处么？让我们来看几个场景。 场景一：让镜像变成像命令一样使用 假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现： FROM ubuntu:18.04 RUN apt-get update \\ && apt-get install -y curl \\ && rm -rf /var/lib/apt/lists/* CMD [ \"curl\", \"-s\", \"https://ip.cn\" ] 假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行： $ docker run myip 当前 IP：61.148.226.66 来自：北京市 联通 嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？ $ docker run myip -i docker: Error response from daemon: invalid header field value \"oci runtime error: container_linux.go:247: starting container process caused \\\"exec: \\\\\\\"-i\\\\\\\": executable file not found in $PATH\\\"\\n\". 我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s https://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。 那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令： $ docker run myip curl -s https://ip.cn -i 这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像： FROM ubuntu:18.04 RUN apt-get update \\ && apt-get install -y curl \\ && rm -rf /var/lib/apt/lists/* ENTRYPOINT [ \"curl\", \"-s\", \"https://ip.cn\" ] 这次我们再来尝试直接使用 docker run myip -i： $ docker run myip 当前 IP：61.148.226.66 来自：北京市 联通 $ docker run myip -i HTTP/1.1 200 OK Server: nginx/1.8.0 Date: Tue, 22 Nov 2016 05:12:40 GMT Content-Type: text/html; charset=UTF-8 Vary: Accept-Encoding X-Powered-By: PHP/5.6.24-1~dotdeb+7.1 X-Cache: MISS from cache-2 X-Cache-Lookup: MISS from cache-2:80 X-Cache: MISS from proxy-2_6 Transfer-Encoding: chunked Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006 Connection: keep-alive 当前 IP：61.148.226.66 来自：北京市 联通 可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。 场景二：应用运行前的准备工作 启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。 比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。 此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。 这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 ）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的： FROM alpine:3.4 ... RUN addgroup -S redis && adduser -S -G redis redis ... ENTRYPOINT [\"docker-entrypoint.sh\"] EXPOSE 6379 CMD [ \"redis-server\" ] 可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。 #!/bin/sh ... # allow the container to be started with `--user` if [ \"$1\" = 'redis-server' -a \"$(id -u)\" = '0' ]; then chown -R redis . exec su-exec redis \"$0\" \"$@\" fi exec \"$@\" 该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如： $ docker run -it redis id uid=0(root) gid=0(root) groups=0(root) powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:39 "},"article/Docker/Chapter5/5-9-env.html":{"url":"article/Docker/Chapter5/5-9-env.html","title":"5.9 ENV 设置环境变量","keywords":"","body":"ENV 设置环境变量 1、格式 ENV ENV = =... 2、作用 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。 ENV VERSION=1.0 DEBUG=on \\ NAME=\"Happy Feet\" 这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。 定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码： ENV NODE_VERSION 7.2.0 RUN curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz\" \\ && curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\" \\ && gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \\ && grep \" node-v$NODE_VERSION-linux-x64.tar.xz\\$\" SHASUMS256.txt | sha256sum -c - \\ && tar -xJf \"node-v$NODE_VERSION-linux-x64.tar.xz\" -C /usr/local --strip-components=1 \\ && rm \"node-v$NODE_VERSION-linux-x64.tar.xz\" SHASUMS256.txt.asc SHASUMS256.txt \\ && ln -s /usr/local/bin/node /usr/local/bin/nodejs 在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。 下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。 可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。 powered by Gitbook该文件最后修改时间： 2020-03-30 14:49:19 "},"article/Docker/Chapter5/5-10-arg.html":{"url":"article/Docker/Chapter5/5-10-arg.html","title":"5.10 ARG 构建参数","keywords":"","body":"ARG 构建参数 1、格式 ARG [=] 2、作用 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。 Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 --build-arg = 来覆盖。 在 1.13 之前的版本，要求 --build-arg 中的参数名，必须在 Dockerfile 中用 ARG 定义过了，换句话说，就是 --build-arg 指定的参数，必须在 Dockerfile 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 Dockerfile 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。 powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-11-volume.html":{"url":"article/Docker/Chapter5/5-11-volume.html","title":"5.11 VOLUME 定义匿名卷","keywords":"","body":"VOLUME 定义匿名卷 1、格式 VOLUME [\"\", \"\"...] VOLUME 2、作用 容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 VOLUME /data 这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如： docker run -d -v mydata:/data xxxx 在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。 powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-12-expose.html":{"url":"article/Docker/Chapter5/5-12-expose.html","title":"5.12 EXPOSE 暴露端口","keywords":"","body":"EXPOSE 声明端口 1、格式 EXPOSE [...] 2、作用 EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处： 一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射； 另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 要将 EXPOSE 和在运行时使用 -p : 区分开来。 -p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问， EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-13-workdir.html":{"url":"article/Docker/Chapter5/5-13-workdir.html","title":"5.13 WORKDIR 指定工作目录","keywords":"","body":"WORKDIR 指定工作目录 1、格式 WORKDIR 2、作用 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 之前提到常见的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误： RUN cd /app RUN echo \"hello\" > world.txt 如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。 之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。 powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-14-user.html":{"url":"article/Docker/Chapter5/5-14-user.html","title":"5.14 USER 指定当前用户","keywords":"","body":"USER 指定当前用户 1、格式 USER [:] 2、作用 USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。 WORKDIR 是改变工作目录 USER 是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。 当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。 RUN groupadd -r redis && useradd -r -g redis redis USER redis RUN [ \"redis-server\" ] 如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu。 # 建立 redis 用户，并使用 gosu 换另一个用户执行命令 RUN groupadd -r redis && useradd -r -g redis redis # 下载 gosu RUN wget -O /usr/local/bin/gosu \"https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64\" \\ && chmod +x /usr/local/bin/gosu \\ && gosu nobody true # 设置 CMD，并以另外的用户执行 CMD [ \"exec\", \"gosu\", \"redis\", \"redis-server\" ] powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-15-healthcheck.html":{"url":"article/Docker/Chapter5/5-15-healthcheck.html","title":"5.15 HEALTHCHECK 健康检查","keywords":"","body":"HEALTHCHECK 健康检查 1、格式 HEALTHCHECK [选项] CMD ：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 2、作用 HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常 在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。 当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。 HEALTHCHECK 支持下列选项： --interval=：两次健康检查的间隔，默认为 30 秒； --timeout=：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒； --retries=：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。 和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。 在 HEALTHCHECK [选项] CMD 后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。 假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写： FROM nginx RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/* HEALTHCHECK --interval=5s --timeout=3s \\ CMD curl -fs http://localhost/ || exit 1 这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit 1 作为健康检查命令。 使用 docker build 来构建这个镜像： $ docker build -t myweb:v1 . 构建好了后，我们启动一个容器： $ docker run -d --name web -p 80:80 myweb:v1 当运行该镜像后，可以通过 docker container ls 看到最初的状态为 (health: starting)： $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 \"nginx -g 'daemon off\" 3 seconds ago Up 2 seconds (health: starting) 80/tcp, 443/tcp web 在等待几秒钟后，再次 docker container ls，就会看到健康状态变化为了 (healthy)： $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 \"nginx -g 'daemon off\" 18 seconds ago Up 16 seconds (healthy) 80/tcp, 443/tcp web 如果健康检查连续失败超过了重试次数，状态就会变为 (unhealthy)。 为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看。 $ docker inspect --format '{{json .State.Health}}' web | python -m json.tool { \"FailingStreak\": 0, \"Log\": [ { \"End\": \"2016-11-25T14:35:37.940957051Z\", \"ExitCode\": 0, \"Output\": \"\\n\\n\\nWelcome to nginx!\\n\\n body {\\n width: 35em;\\n margin: 0 auto;\\n font-family: Tahoma, Verdana, Arial, sans-serif;\\n }\\n\\n\\n\\nWelcome to nginx!\\nIf you see this page, the nginx web server is successfully installed and\\nworking. Further configuration is required.\\n\\nFor online documentation and support please refer to\\nnginx.org.\\nCommercial support is available at\\nnginx.com.\\n\\nThank you for using nginx.\\n\\n\\n\", \"Start\": \"2016-11-25T14:35:37.780192565Z\" } ], \"Status\": \"healthy\" } powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter5/5-16-saveload.html":{"url":"article/Docker/Chapter5/5-16-saveload.html","title":"5.16 SAVE/LOAD","keywords":"","body":"docker save 和 docker load Docker 还提供了 docker save 和 docker load 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。 保存镜像 使用 docker save 命令可以将镜像保存为归档文件。 比如我们希望保存这个 alpine 镜像。 $ docker image ls alpine REPOSITORY TAG IMAGE ID CREATED SIZE alpine latest baa5d63471ea 5 weeks ago 4.803 MB 保存镜像的命令为： $ docker save alpine -o filename $ file filename filename: POSIX tar archive 这里的 filename 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件 注意：如果同名则会覆盖（没有警告） 若使用 gzip 压缩： $ docker save alpine | gzip > alpine-latest.tar.gz 加载镜像 然后我们将 alpine-latest.tar.gz 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像： $ docker load -i alpine-latest.tar.gz Loaded image: alpine:latest 如果我们结合这两个命令以及 ssh 甚至 pv 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能： docker save | bzip2 | pv | ssh @ 'cat | docker load' powered by Gitbook该文件最后修改时间： 2020-03-30 14:42:38 "},"article/Docker/Chapter6/6-1-start.html":{"url":"article/Docker/Chapter6/6-1-start.html","title":"6.1 启动","keywords":"","body":"启动容器 启动容器有两种方式 基于镜像新建一个容器并启动 将在终止状态（stopped）的容器重新启动。 因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。 新建并启动 所需要的命令主要为 docker run。 例如，下面的命令输出一个 “Hello World”，之后终止容器。 [root@docker ~]# docker run ubuntu:18.04 /bin/echo 'Hello world' Hello world 这跟在本地直接执行 /bin/echo 'hello world' 几乎感觉不出任何区别。 下面的命令则启动一个 bash 终端，允许用户进行交互。 [root@docker ~]# docker run -t -i ubuntu:18.04 /bin/bash root@fb55bebd07b5:/# 其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。 在交互模式下，用户可以通过所创建的终端来输入命令，例如 root@fb55bebd07b5:/# pwd / root@fb55bebd07b5:/# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 启动已终止容器 可以利用 docker start 命令，直接将一个已经终止的容器启动运行。 容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。 root@fb55bebd07b5:/# ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 11 pts/0 00:00:00 ps 可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。 powered by Gitbook该文件最后修改时间： 2020-03-30 15:29:22 "},"article/Docker/Chapter6/6-2-backend.html":{"url":"article/Docker/Chapter6/6-2-backend.html","title":"6.2 后台运行","keywords":"","body":"后台运行 更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。 下面举两个例子来说明一下。 如果不使用 -d 参数运行容器。 [root@docker ~]# docker run ubuntu:18.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\" hello world hello world hello world hello world 容器会把输出的结果 (STDOUT) 打印到宿主机上面 如果使用了 -d 参数运行容器。 [root@docker ~]# docker run -d ubuntu:18.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 26e3a0f3c836da943f7ad1677bfede3ae87b7ba8b1a680b1997636c3a5552c84 此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。 注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。 使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker ps 命令来查看容器信息。 [root@docker ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 26e3a0f3c836 ubuntu:18.04 \"/bin/sh -c 'while t…\" 12 seconds ago Up 11 seconds frosty_johnson 要获取容器的输出信息，可以通过 docker container logs 命令。 [root@docker ~]# docker container logs 26e3a0f3c836 hello world hello world hello world hello world hello world hello world hello world hello world . . . powered by Gitbook该文件最后修改时间： 2020-03-30 15:29:22 "},"article/Docker/Chapter6/6-3-stop.html":{"url":"article/Docker/Chapter6/6-3-stop.html","title":"6.3 终止","keywords":"","body":"终止容器 可以使用 docker stop 来终止一个运行中的容器。 [root@docker ~]# docker stop 27ee12a35471 27ee12a35471 此外，当 Docker 容器中指定的应用终结时，容器也自动终止。 例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。 终止状态的容器可以用 docker ps -a 命令看到。例如 [root@docker ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 27ee12a35471 ubuntu:18.04 \"/bin/sh -c 'while t…\" 37 seconds ago Exited (137) 8 seconds ago competent_albattani backstabbing_pike 处于终止状态的容器，可以通过 docker start 命令来重新启动。 此外，docker restart 命令会将一个运行态的容器终止，然后再重新启动它。 powered by Gitbook该文件最后修改时间： 2020-03-30 15:29:22 "},"article/Docker/Chapter6/6-4-exec.html":{"url":"article/Docker/Chapter6/6-4-exec.html","title":"6.4 进入容器","keywords":"","body":"进入容器 在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。 attach命令 下面示例如何使用 docker attach 命令。 [root@docker ~]# docker run -dit ubuntu:18.04 d1e04dbec84bd378b3223dcb22a29ed2f57fe226d0a140e2fc5b94b7391ad298 [root@docker ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d1e04dbec84b ubuntu:18.04 \"/bin/bash\" 7 seconds ago Up 6 seconds friendly_proskuriakova [root@docker ~]# docker attach d1e04dbec84b root@d1e04dbec84b:/# 注意： 如果从这个 stdin 中 exit，会导致容器的停止。 exec 命令 -i -t 参数 docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。 只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。 当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。 [root@docker ~]# docker run -dit ubuntu:18.04 c0b2edc0c5eeb38866e8ca1555e86c3bd0d4e17a93f7f9de497434a13aa14371 [root@docker ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c0b2edc0c5ee ubuntu:18.04 \"/bin/bash\" 15 seconds ago Up 14 seconds nice_proskuriakova [root@docker ~]# docker exec -i c0b2edc0c5ee bash ls bin boot dev etc home lib ... [root@docker ~]# docker exec -it c0b2edc0c5ee bash root@c0b2edc0c5ee:/# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin 如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因 powered by Gitbook该文件最后修改时间： 2020-03-30 15:29:22 "},"article/Docker/Chapter6/6-5-export.html":{"url":"article/Docker/Chapter6/6-5-export.html","title":"6.5 导出和导入","keywords":"","body":"导出和导入容器 导出容器 如果要导出本地某个容器，可以使用 docker export 命令。 [root@docker ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c0b2edc0c5ee ubuntu:18.04 \"/bin/bash\" 36 hours ago Exited (0) 21 hours ago test [root@docker ~]# docker export c0b2edc0c5ee > ubuntu.tar 这样将导出容器快照到本地文件。 导入容器快照 可以使用 docker import 从容器快照文件中再导入为镜像，例如 [root@docker ~]# cat ubuntu.tar | docker import - test/ubuntu:v1.0 sha256:0bbbaf44fab08a3302ff00199176f1d1d5ecc0a16d6e01ea203c281a82095298 [root@docker ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE test/ubuntu v1.0 0bbbaf44fab0 2 seconds ago 64.2MB 此外，也可以通过指定 URL 或者某个目录来导入，例如 $ docker import http://example.com/exampleimage.tgz example/imagerepo powered by Gitbook该文件最后修改时间： 2020-03-30 15:29:22 "},"article/Docker/Chapter6/6-6-delete.html":{"url":"article/Docker/Chapter6/6-6-delete.html","title":"6.6 删除","keywords":"","body":"删除容器 可以使用 docker rm 来删除一个处于终止状态的容器。例如 [root@docker ~]# docker rm c0b2edc0c5ee c0b2edc0c5ee 如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。 清理所有处于终止状态的容器 用 docker ps -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。 $ docker container prune powered by Gitbook该文件最后修改时间： 2020-03-30 15:29:22 "},"article/Docker/Chapter7/7-1-repository.html":{"url":"article/Docker/Chapter7/7-1-repository.html","title":"7.1 仓库","keywords":"","body":"仓库（Repository） 仓库（Repository）是集中存储镜像的地方，这里有个概念要区分一下，那就是仓库与仓库服务器(Registry)是两回事，像我们上面说的Docker Hub，就是Docker官方提供的一个仓库服务器，不过其实有时候我们不太需要太过区分这两个概念。 公共仓库 公共仓库一般是指Docker Hub，前面我们已经多次介绍如何从 Docker Hub 获取镜像，除了获取镜像外，我们也可以将自己构建的镜像存放到Docker Hub，这样，别人也可以使用我们构建的镜像。 不过要将镜像上传到Docker Hub，必须先在Docker的官方网站上注册一个账号，注册界面如下，按要求填写必要的信息就可以注册了，很简单的。 私有仓库 在 Docker 中，当我们执行 docker pull xxx 的时候 ，它实际上是从 registry.hub.docker.com 这个地址去查找，这就是Docker公司为我们提供的公共仓库。在工作中，我们不可能把企业项目push到公有仓库进行管理。所以为了更好的管理镜像，Docker不仅提供了一个中央仓库，同时也允许我们搭建本地私有仓库。 powered by Gitbook该文件最后修改时间： 2020-03-31 10:01:56 "},"article/Docker/Chapter7/7-2-dockerhub.html":{"url":"article/Docker/Chapter7/7-2-dockerhub.html","title":"7.2 Docker Hub","keywords":"","body":"Docker Hub 目前 Docker 官方维护了一个公共仓库 Docker Hub。 大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。 注册 在 https://hub.docker.com 免费注册一个 Docker 账号。 登录 登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。 [root@docker ~]# docker login Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: testuser Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 退出 退出 docker hub 可以使用以下命令： [root@docker ~]# docker logout Removing login credentials for https://index.docker.io/v1/ 拉取镜像 你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。 以 ubuntu 为关键词进行搜索： [root@docker ~]# docker search ubuntu NAME DESCRIPTION STARS OFFICIAL AUTOMATED ubuntu Ubuntu is a Debian-based Linux operating sys… 10693 [OK] dorowu/ubuntu-desktop-lxde-vnc Docker image to provide HTML5 VNC interface … 410 [OK] rastasheep/ubuntu-sshd Dockerized SSH service, built on top of offi… 245 [OK] consol/ubuntu-xfce-vnc Ubuntu container with \"headless\" VNC session… 212 [OK] ubuntu-upstart Upstart is an event-based replacement for th… 107 [OK] ansible/ubuntu14.04-ansible Ubuntu 14.04 LTS with ansible 98 [OK] neurodebian NeuroDebian provides neuroscience research s… 67 [OK] 1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5 ubuntu-16-nginx-php-phpmyadmin-mysql-5 50 [OK] 使用 docker pull 将官方 ubuntu 镜像下载到本地： [root@docker ~]# docker pull ubuntu Using default tag: latest latest: Pulling from library/ubuntu Digest: sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d Status: Image is up to date for ubuntu:latest docker.io/library/ubuntu:latest 推送镜像 用户登录后，可以通过 docker push 命令将自己的镜像推送到 Docker Hub。 以下命令中的 username 请替换为你的 Docker 账号用户名。 [root@docker ~]# docker tag ubuntu:18.04 username/ubuntu:18.04 [root@docker ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE rclone v1 6642ba8323a4 17 hours ago 399MB test/ubuntu v1.0 0bbbaf44fab0 18 hours ago 64.2MB username/ubuntu 18.04 4e5021d210f6 10 days ago 64.2MB ubuntu 18.04 4e5021d210f6 10 days ago 64.2MB ubuntu latest 4e5021d210f6 10 days ago 64.2MB rclone/rclone latest 077820eefe46 8 weeks ago 40.2MB centos 7 5e35e350aded 4 months ago 203MB [root@docker ~]# docker push username/ubuntu:18.04 The push refers to repository [docker.io/username/ubuntu] 16542a8fc3be: Layer already exists 6597da2e2e52: Layer already exists 977183d4e999: Layer already exists c8be1b8f4d60: Layer already exists 18.04: digest: sha256:e5dd9dbb37df5b003359f6f126958c9c928f937bec69836320 size: 1152 powered by Gitbook该文件最后修改时间： 2020-03-31 10:01:56 "},"article/Docker/Chapter7/7-3-registry.html":{"url":"article/Docker/Chapter7/7-3-registry.html","title":"7.3 Registry","keywords":"","body":"私有仓库 有时候自己部门内部有一些镜像要共享时，如果直接导出镜像拿给别人又比较麻烦，使用像Docker Hub这样的公共仓库又不是很方便，这时候我们可以自己搭建属于自己的私有仓库服务，用于存储和分布我们的镜像。 Docker官方提供了registry这个镜像，可以用于搭建私有仓库服务，我们把镜像拉到本地之后，用下面命令创建该镜像的容器便可以搭建一个仓库服务，如下： [root@docker ~]# docker run -d -p 5000:5000 --restart=always --name registry registry Unable to find image 'registry:latest' locally latest: Pulling from library/registry 486039affc0a: Pull complete ba51a3b098e6: Pull complete 8bb4c43d6c8e: Pull complete 6f5f453e5f2d: Pull complete 42bc10b72f42: Pull complete Digest: sha256:7d081088e4bfd632a88e3f3bcd9e007ef44a796fddfe3261407a3f9f04abe1e7 Status: Downloaded newer image for registry:latest d6fb06b351e82ad6fd16a41d4a5b8969b016cd237732d22addf7beabe82e8c9e 推送镜像 [root@docker ~]# docker tag ubuntu:18.04 127.0.0.1:5000/ubuntu:v1 [root@docker ~]# docker push 127.0.0.1:5000/ubuntu:v1 The push refers to repository [127.0.0.1:5000/ubuntu] 16542a8fc3be: Pushed 6597da2e2e52: Pushed 977183d4e999: Pushed c8be1b8f4d60: Pushed v1: digest: sha256:e5dd9dbb37df5b731a6688fa49f4003359f6f126958c9c928f937bec69836320 size: 1152 拉取镜像 [root@docker ~]# docker pull 127.0.0.1:5000/ubuntu:v1 v1: Pulling from ubuntu 5bed26d33875: Pull complete f11b29a9c730: Pull complete 930bda195c84: Pull complete 78bf9a5ad49e: Pull complete Digest: sha256:e5dd9dbb37df5b731a6688fa49f4003359f6f126958c9c928f937bec69836320 Status: Downloaded newer image for 127.0.0.1:5000/ubuntu:v1 127.0.0.1:5000/ubuntu:v1 powered by Gitbook该文件最后修改时间： 2020-03-31 10:01:56 "},"article/Docker/Chapter8/8-1-volume.html":{"url":"article/Docker/Chapter8/8-1-volume.html","title":"8.1 数据卷","keywords":"","body":"数据卷 数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 可以在容器之间共享和重用 对 数据卷的修改会立马生效 对 数据卷 的更新，不会影响镜像 数据卷 默认会一直存在，即使容器被删除 创建一个数据卷 [root@docker ~]# docker volume create my-vol my-vol 查看所有的 数据卷 [root@docker ~]# docker volume ls DRIVER VOLUME NAME local 9186dbebe36c0273686adcf4519a2e99706546d0425f4f9999f61d14aaaf566e local my-vol 查看指定卷的详情信息 [root@docker ~]# docker volume inspect my-vol [ { \"CreatedAt\": \"2020-03-31T10:24:06+08:00\", \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\", \"Name\": \"my-vol\", \"Options\": {}, \"Scope\": \"local\" } ] 启动一个挂载数据卷的容器 在用 docker run 命令的时候，使用 --mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。 下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。 [root@docker ~]# docker run -d -P \\ > --name web \\ > --mount source=my-vol,target=/webapp \\ > training/webapp \\ > python app.py 数据卷信息在 \"Mounts\" Key 下面 [root@docker ~]# docker inspect web \"Mounts\": [ { \"Type\": \"volume\", \"Name\": \"my-vol\", \"Source\": \"/var/lib/docker/volumes/my-vol/_data\", \"Destination\": \"/webapp\", \"Driver\": \"local\", \"Mode\": \"z\", \"RW\": true, \"Propagation\": \"\" } ], 删除数据卷 [root@docker ~]# docker volume rm my-vol my-vol 数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。 无主的数据卷可能会占据很多空间，要清理请使用以下命令 $ docker volume prune powered by Gitbook该文件最后修改时间： 2020-03-31 10:46:02 "},"article/Docker/Chapter8/8-2-mount.html":{"url":"article/Docker/Chapter8/8-2-mount.html","title":"8.2 挂载主机目录","keywords":"","body":"挂载主机目录 挂载一个主机目录作为数据卷 使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。 [root@docker ~]# docker run -d -P \\ > --name web \\ > --mount type=bind,source=/src/webapp,target=/opt/webapp \\ > training/webapp \\ > python app.py 上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 --mount 参数时如果本地目录不存在，Docker 会报错。 docker: Error response from daemon: invalid mount config for type \"bind\": bind source path does not exist: /src/webapp. Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读。 $ docker run -d -P \\ --name web \\ --mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \\ training/webapp \\ python app.py 加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /opt/webapp 目录新建文件，会显示如下错误 [root@docker ~]# docker exec -it 11a253e0372f bash root@11a253e0372f:/opt/webapp# cd /webapp/ root@11a253e0372f:/webapp# ls root@11a253e0372f:/webapp# touch 123 touch: cannot touch '123': Read-only file system 挂载一个本地主机文件作为数据卷 --mount 标记也可以从主机挂载单个文件到容器中 docker run --rm -it \\ --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \\ ubuntu:18.04 \\ bash root@d7e3e687a07d:/# history |head -10 1 2 wget 106.54.179.232 这样就可以记录在容器输入过的命令了。 powered by Gitbook该文件最后修改时间： 2020-03-31 10:46:02 "},"article/Docker/Chapter9/9-1-external.html":{"url":"article/Docker/Chapter9/9-1-external.html","title":"9.1 外部访问容器","keywords":"","body":"外部访问容器 容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。 当使用 -P 标记时，Docker 会随机映射一个的端口到内部容器开放的网络端口。 使用 docker ps 可以看到，本地主机的 32773 被映射到了容器的 5000 端口。此时访问本机的 32773 端口即可访问容器内 web 应用提供的界面。 [root@docker ~]# docker run -d -P training/webapp python app.py 6b7c9e7ffb7fa7c58c1c005d89aeb6a627faa7cc60afffc956d76f1e27244855 [root@docker ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6b7c9e7ffb7f training/webapp \"python app.py\" 6 seconds ago Up 5 seconds 0.0.0.0:32773->5000/tcp cranky_bardeen 同样的，可以通过 docker logs 命令来查看应用的信息。 [root@docker ~]# docker logs -f 6b7c9e7ffb7f * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit) 123.139.156.117 - - [31/Mar/2020 03:13:50] \"GET / HTTP/1.1\" 200 - 123.139.156.117 - - [31/Mar/2020 03:13:50] \"GET /favicon.ico HTTP/1.1\" 404 - -p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort 映射所有接口地址 使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口，可以执行 [root@docker ~]# docker run -d -p 5000:5000 training/webapp python app.py 5b6cd08abfedc7700a79d036609771aa308810e02d9b787f44077c2ad4257dfb [root@docker ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 5b6cd08abfed training/webapp \"python app.py\" 1 second ago Up 1 second 0.0.0.0:5000->5000/tcp epic_pascal 此时默认会绑定本地所有接口上的所有地址。 映射到指定地址的指定端口 可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1 [root@docker ~]# docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py 映射到指定地址的任意端口 使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。 [root@docker ~]# docker run -d -p 127.0.0.1::5000 training/webapp python app.py 还可以使用 udp 标记来指定 udp 端口 [root@docker ~]# docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py 查看映射端口配置 使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址 [root@docker ~]# docker port epic_pascal 5000 0.0.0.0:5000 注意： 容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。） -p 标记可以多次使用来绑定多个端口 例如 [root@docker ~]# docker run -d \\ -p 5000:5000 \\ -p 3000:80 \\ training/webapp \\ python app.py powered by Gitbook该文件最后修改时间： 2020-03-31 11:23:44 "},"article/Docker/Chapter9/9-2-interconnection.html":{"url":"article/Docker/Chapter9/9-2-interconnection.html","title":"9.2 容器互联","keywords":"","body":"容器互联 如果你之前有 Docker 使用经验，你可能已经习惯了使用 --link 参数来使容器互联。 随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 --link 参数。 新建网络 下面先创建一个新的 Docker 网络。 [root@docker ~]# docker network create -d bridge my-net dc5e496d3916b5d92ea7485efdf0ae3efec48b0a90aea58b9809c00a772f6a43 -d 参数指定 Docker 网络类型，有 bridge overlay。其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。 连接容器 运行一个容器并连接到新建的 my-net 网络 [root@docker ~]# docker run -it --rm --name busybox1 --network my-net busybox sh 打开新的终端，再运行一个容器并加入到 my-net 网络 [root@docker ~]# docker run -it --rm --name busybox2 --network my-net busybox sh 再打开一个新的终端查看容器信息 [root@docker ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e68a95bd0aea busybox \"sh\" 25 seconds ago Up 24 seconds busybox2 43508748a446 busybox \"sh\" About a minute ago Up About a minute busybox1 下面通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。 在 busybox1 容器输入以下命令 / # ping busybox2 PING busybox2 (172.19.0.3): 56 data bytes 64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms 64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms 用 ping 来测试连接 busybox2 容器，它会解析成 172.19.0.3。 同理在 busybox2 容器执行 ping busybox1，也会成功连接到。 / # ping busybox1 PING busybox1 (172.19.0.2): 56 data bytes 64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms 64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms 这样，busybox1 容器和 busybox2 容器建立了互联关系。 powered by Gitbook该文件最后修改时间： 2020-03-31 11:23:44 "},"article/Docker/Chapter9/9-3-dns.html":{"url":"article/Docker/Chapter9/9-3-dns.html","title":"9.3 配置DNS","keywords":"","body":"配置 DNS 如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。 在容器中使用 mount 命令可以看到挂载信息： $ mount /dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 ... /dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ... tmpfs on /etc/resolv.conf type tmpfs ... 这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 /etc/resolv.conf 文件立刻得到更新。 配置全部容器的 DNS ，也可以在 /etc/docker/daemon.json 文件中增加以下内容来设置。 { \"dns\" : [ \"114.114.114.114\", \"8.8.8.8\" ] } 这样每次启动的容器 DNS 自动配置为 114.114.114.114 和 8.8.8.8。使用以下命令来证明其已经生效。 [root@docker ~]# docker run -it --rm ubuntu:18.04 cat etc/resolv.conf nameserver 114.114.114.114 nameserver 8.8.8.8 如果用户想要手动指定容器的配置，可以在使用 docker run 命令启动容器时加入如下参数： -h HOSTNAME 或者 --hostname=HOSTNAME 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。但它在容器外部看不到，既不会在 docker container ls 中显示，也不会在其他的容器的 /etc/hosts 看到。 --dns=IP_ADDRESS 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。 --dns-search=DOMAIN 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。 powered by Gitbook该文件最后修改时间： 2020-03-31 11:23:45 "},"article/Docker/Chapter10/10-1-base.html":{"url":"article/Docker/Chapter10/10-1-base.html","title":"10.1 简介","keywords":"","body":"Compose 简介 Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 OpenStack 中的 Heat 十分类似。 其代码目前在 https://github.com/docker/compose 上开源。 Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。 通过第一部分中的介绍，我们知道使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。 Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Compose 中有两个重要的概念： 服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。 Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。 powered by Gitbook该文件最后修改时间： 2020-03-31 14:04:57 "},"article/Docker/Chapter10/10-2-install.html":{"url":"article/Docker/Chapter10/10-2-install.html","title":"10.2 安装与卸载","keywords":"","body":"安装与卸载 Compose 支持 Linux、macOS、Windows 10 三大平台。 Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。 Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用。 $ docker-compose --version docker-compose version 1.24.1, build 4667896b Linux 系统请使用以下介绍的方法安装。 方法一：二进制包 在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。 例如，在 Linux 64 位系统上直接下载对应的二进制包。 $ sudo curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose $ sudo chmod +x /usr/local/bin/docker-compose 方法二：PIP 安装 注： x86_64 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 ARM (例如，树莓派)，再使用 pip 安装。 这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。 执行安装命令： $ sudo pip install -U docker-compose 可以看到类似如下输出，说明安装成功。 Collecting docker-compose Downloading docker-compose-1.25.4.tar.gz (149kB): 149kB downloaded ... Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress bash 补全命令 $ curl -L https://raw.githubusercontent.com/docker/compose/1.25.4/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose 卸载 如果是二进制包方式安装的，删除二进制文件即可。 $ sudo rm /usr/local/bin/docker-compose 如果是通过 pip 安装的，则执行如下命令即可删除。 $ sudo pip uninstall docker-compose powered by Gitbook该文件最后修改时间： 2020-03-31 14:04:57 "},"article/Docker/Chapter10/10-3-use.html":{"url":"article/Docker/Chapter10/10-3-use.html","title":"10.3 使用","keywords":"","body":"使用 术语 首先介绍几个术语。 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。 可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。 场景 最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。 下面我们用 Python 来建立一个能够记录页面访问次数的 web 网站。 web 应用 新建文件夹，在该目录中编写 app.py 文件 from flask import Flask from redis import Redis app = Flask(__name__) redis = Redis(host='redis', port=6379) @app.route('/') def hello(): count = redis.incr('hits') return 'Hello World! 该页面已被访问 {} 次。\\n'.format(count) if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", debug=True) Dockerfile 编写 Dockerfile 文件，内容为 FROM python:3.6-alpine ADD . /code WORKDIR /code RUN pip install redis flask CMD [\"python\", \"app.py\"] docker-compose.yml 编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。 version: '3' services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 运行 compose 项目 $ docker-compose up 此时访问本地 5000 端口，每次刷新页面，计数就会加 1。 powered by Gitbook该文件最后修改时间： 2020-03-31 14:04:57 "},"article/Docker/Chapter10/10-4-command.html":{"url":"article/Docker/Chapter10/10-4-command.html","title":"10.4 命令说明","keywords":"","body":"命令说明 命令对象与格式 对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。 执行 docker-compose [COMMAND] --help 或者 docker-compose help [COMMAND] 可以查看具体某个命令的使用格式。 docker-compose 命令的基本的使用格式是 docker-compose [-f=...] [options] [COMMAND] [ARGS...] 命令选项 -f, --file FILE 指定使用的 Compose 模板文件，默认为 `docker-compose.yml`，可以多次指定。 -p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。 --x-networking 使用 Docker 的可拔插网络后端特性 --x-network-driver DRIVER` 指定网络后端的驱动，默认为 `bridge` --verbose 输出更多调试信息。 -v, --version 打印版本并退出。 build 格式为 docker-compose build [options] [SERVICE...] 构建（重新构建）项目中的服务容器。 服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db 可以随时在项目目录下运行 docker-compose build 来重新构建服务 选项包括： --force-rm 删除构建过程中的临时容器 --no-cache 构建镜像过程中不使用 cache（这将加长构建过程） --pull 始终尝试通过 pull 来获取更新版本的镜像 config 验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因 down 此命令将会停止 up 命令所启动的容器，并移除网络 exec 进入指定的容器 help 获得一个命令的帮助 images 列出 Compose 文件中包含的镜像。 kill 格式为 docker-compose kill [options] [SERVICE...] 通过发送 SIGKILL 信号来强制停止服务容器 支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号 [root@docker ~]# docker-compose kill -s SIGINT logs 格式为 docker-compose logs [options] [SERVICE...]。 查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 --no-color 来关闭颜色。 该命令在调试问题的时候十分有用。 pause 格式为 docker-compose pause [SERVICE...]。 暂停一个服务容器。 port 格式为 docker-compose port [options] SERVICE PRIVATE_PORT。 打印某个容器端口所映射的公共端口。 选项： --protocol=proto 指定端口协议，tcp（默认值）或者 udp。 --index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。 ps 格式为 docker-compose ps [options] [SERVICE...]。 列出项目中目前的所有容器。 选项： -q 只打印容器的 ID 信息。 pull 格式为 docker-compose pull [options] [SERVICE...]。 拉取服务依赖的镜像。 选项： --ignore-pull-failures 忽略拉取镜像过程中的错误。 push 推送服务依赖的镜像到 Docker 镜像仓库。 restart 格式为 docker-compose restart [options] [SERVICE...]。 重启项目中的服务。 选项： -t, --timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。 rm 格式为 docker-compose rm [options] [SERVICE...]。 删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。 选项： -f, --force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。 -v 删除容器所挂载的数据卷。 run 格式为 docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]。 在指定服务上执行一个命令。 例如： [root@docker ~]# docker-compose run ubuntu ping docker.com 将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。 默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。 该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。 两个不同点： 给定命令将会覆盖原有的自动运行命令； 不会自动创建端口，以避免冲突。 如果不希望自动启动关联的容器，可以使用 --no-deps 选项，例如 $ docker-compose run --no-deps web python manage.py shell 将不会启动 web 容器所关联的其它容器。 选项： -d 后台运行容器。 --name NAME 为容器指定一个名字。 --entrypoint CMD 覆盖默认的容器启动指令。 -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。 -u, --user=\"\" 指定运行容器的用户名或者 uid。 --no-deps 不自动启动关联的服务容器。 --rm 运行命令后自动删除容器，d 模式下将忽略。 -p, --publish=[] 映射容器端口到本地主机。 --service-ports 配置服务端口并映射到本地主机。 -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。 scale 格式为 docker-compose scale [options] [SERVICE=NUM...]。 设置指定服务运行的容器个数。 通过 service=num 的参数来设置数量。例如： [root@docker ~]# docker-compose scale web=3 db=2 将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。 一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 start 格式为 docker-compose start [SERVICE...]。 启动已经存在的服务容器。 stop 格式为 docker-compose stop [options] [SERVICE...]。 停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。 选项： -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 top 查看各个服务容器内运行的进程。 unpause 格式为 docker-compose unpause [SERVICE...]。 恢复处于暂停状态中的服务。 up 格式为 docker-compose up [options] [SERVICE...]。 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。 链接的服务都将会被自动启动，除非已经处于运行状态。 可以说，大部分时候都可以直接通过该命令来启动一个项目。 默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。 当通过 Ctrl-C 停止命令时，所有容器将会停止。 如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。 默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up --no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。 选项： -d 在后台运行服务容器。 --no-color 不使用颜色来区分不同的服务的控制台输出。 --no-deps 不启动服务所链接的容器。 --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。 --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。 --no-build 不自动构建缺失的服务镜像。 -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。 version 格式为 docker-compose version。 打印版本信息 [root@docker ~]# docker-compose version docker-compose version 1.25.4, build 8d51620a docker-py version: 4.1.0 CPython version: 3.7.5 OpenSSL version: OpenSSL 1.1.0l 10 Sep 2019 powered by Gitbook该文件最后修改时间： 2020-03-31 14:04:57 "},"article/Docker/Chapter10/10-5-django.html":{"url":"article/Docker/Chapter10/10-5-django.html","title":"10.5 Django","keywords":"","body":"使用 Django 使用 Docker Compose 配置并运行一个 Django/PostgreSQL 应用。 1、编辑 Dockerfile FROM python:3 ENV PYTHONUNBUFFERED 1 RUN mkdir /code WORKDIR /code COPY requirements.txt /code/ RUN pip install -r requirements.txt COPY . /code/ 以上内容指定应用将使用安装了 Python 以及必要依赖包的镜像 2、准备requirements.txt 在 requirements.txt 文件里面写明需要安装的具体依赖包名。 Django>=2.0,=2.7, 3、编辑docker-compose.yml docker-compose.yml 文件将把所有的东西关联起来。它描述了应用的构成（一个 web 服务和一个数据库）、使用的 Docker 镜像、镜像之间的连接、挂载到容器的卷，以及服务开放的端口 version: \"3\" services: db: image: postgres web: build: . command: python manage.py runserver 0.0.0.0:8000 volumes: - .:/code ports: - \"8000:8000\" links: - db 现在我们就可以使用 docker-compose run 命令启动一个 Django 应用了。 [root@docker data]# docker-compose run web django-admin startproject django_example . 由于 web 服务所使用的镜像并不存在，所以 Compose 会首先使用 Dockerfile 为 web 服务构建一个镜像，接着使用这个镜像在容器里运行 django-admin startproject django_example 指令。 这将在当前目录生成一个 Django 应用 $ ls Dockerfile docker-compose.yml django_example manage.py requirements.txt 首先，我们要为应用设置好数据库的连接信息。用以下内容替换 django_example/settings.py 文件中 DATABASES = ... 定义的节点内容。 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql', 'NAME': 'postgres', 'USER': 'postgres', 'HOST': 'db', 'PORT': 5432, } } 这些信息是在 postgres 镜像固定设置好的。然后，运行 docker-compose up ： [root@docker data]# docker-compose up Starting data_db_1 ... done Starting data_web_1 ... done Attaching to data_db_1, data_web_1 db_1 | Error: Database is uninitialized and superuser password is not specified. db_1 | You must specify POSTGRES_PASSWORD to a non-empty value for the db_1 | superuser. For example, \"-e POSTGRES_PASSWORD=password\" on \"docker run\". db_1 | db_1 | You may also use \"POSTGRES_HOST_AUTH_METHOD=trust\" to allow all db_1 | connections without a password. This is *not* recommended. db_1 | db_1 | See PostgreSQL documentation about \"trust\": db_1 | https://www.postgresql.org/docs/current/auth-trust.html data_db_1 exited with code 1 web_1 | Watching for file changes with StatReloader web_1 | Performing system checks... web_1 | web_1 | System check identified no issues (0 silenced). web_1 | web_1 | You have 17 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions. web_1 | Run 'python manage.py migrate' to apply them. web_1 | March 31, 2020 - 05:56:35 web_1 | Django version 2.2.11, using settings 'django_example.settings' web_1 | Starting development server at http://0.0.0.0:8000/ web_1 | Quit the server with CONTROL-C. web_1 | [31/Mar/2020 05:56:39] \"GET / HTTP/1.1\" 200 16348 web_1 | [31/Mar/2020 05:56:39] \"GET /static/admin/css/fonts.css HTTP/1.1\" 200 423 web_1 | [31/Mar/2020 05:56:39] \"GET /static/admin/fonts/Roboto-Bold-webfont.woff HTTP/1.1\" 200 86184 web_1 | [31/Mar/2020 05:56:39] \"GET /static/admin/fonts/Roboto-Regular-webfont.woff HTTP/1.1\" 200 85876 web_1 | [31/Mar/2020 05:56:40] \"GET /static/admin/fonts/Roboto-Light-webfont.woff HTTP/1.1\" 200 85692 web_1 | Not Found: /favicon.ico web_1 | [31/Mar/2020 05:56:41] \"GET /favicon.ico HTTP/1.1\" 404 1986 这个 Django 应用已经开始在你的 Docker 守护进程里监听着 8000 端口了。打开 127.0.0.1:8000 即可看到 Django 欢迎页面。 你还可以在 Docker 上运行其它的管理命令，例如对于同步数据库结构这种事，在运行完 docker-compose up 后，在另外一个终端进入文件夹运行以下命令即可： [root@docker data]# docker-compose run web python manage.py syncdb powered by Gitbook该文件最后修改时间： 2020-03-31 14:04:57 "},"article/Docker/Chapter10/10-6-wordpress.html":{"url":"article/Docker/Chapter10/10-6-wordpress.html","title":"10.6 WordPress","keywords":"","body":"WordPress Compose 可以很便捷的让 Wordpress 运行在一个独立的环境中。 创建空文件夹 假设新建一个名为 wordpress 的文件夹，然后进入这个文件夹。 创建 docker-compose.yml文件 docker-compose.yml 文件将开启一个 wordpress 服务和一个独立的 MySQL 实例： version: \"3\" services: db: image: mysql:8.0 command: - --default_authentication_plugin=mysql_native_password - --character-set-server=utf8mb4 - --collation-server=utf8mb4_unicode_ci volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - \"8000:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress volumes: db_data: 构建并运行项目 运行 docker-compose up -d Compose 就会拉取镜像再创建我们所需要的镜像，然后启动 wordpress 和数据库容器。 接着浏览器访问 127.0.0.1:8000 端口就能看到 WordPress 安装界面了。 powered by Gitbook该文件最后修改时间： 2020-03-31 14:04:57 "},"article/Rancher/Chapter1/1-1-base.html":{"url":"article/Rancher/Chapter1/1-1-base.html","title":"1.1 什么是Rancher","keywords":"","body":"1.1 什么是Rancher Rancher是一套容器管理平台，它可以帮助组织在生产环境中轻松快捷的部署和管理容器。 Rancher可以轻松地管理各种环境的Kubernetes，满足IT需求并为DevOps团队提供支持。 Kubernetes不仅已经成为的容器编排标准，它也正在迅速成为各类云和虚拟化厂商提供的标准基础架构。Rancher用户可以选择使用Rancher Kubernetes Engine(RKE)创建Kubernetes集群，也可以使用GKE，AKS和EKS等云Kubernetes服务。 Rancher用户还可以导入和管理现有的Kubernetes集群。 Rancher支持各类集中式身份验证系统来管理Kubernetes集群。例如，大型企业的员工可以使用其公司Active Directory凭证访问GKE中的Kubernetes集群。IT管理员可以在用户，组，项目，集群和云中设置访问控制和安全策略。 IT管理员可以在单个页面对所有Kubernetes集群的健康状况和容量进行监控。 Rancher为DevOps工程师提供了一个直观的用户界面来管理他们的服务容器，用户不需要深入了解Kubernetes概念就可以开始使用Rancher。 Rancher包含应用商店，支持一键式部署Helm和Compose模板。Rancher通过各种云、本地生态系统产品认证，其中包括安全工具，监控系统，容器仓库以及存储和网络驱动程序。下图说明了Rancher在IT和DevOps组织中扮演的角色。每个团队都会在他们选择的公共云或私有云上部署应用程序。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:38 "},"article/Rancher/Chapter1/1-2-1-docker.html":{"url":"article/Rancher/Chapter1/1-2-1-docker.html","title":"1.2.1 Docker简述","keywords":"","body":"1.2.1、Docker简述 Docker是容器打包和runtime标准。开发人员从Dockerfiles构建容器镜像，并从Docker镜像仓库中分发容器镜像。Docker Hub是最受欢迎的公共镜像仓库，许多组织还设置私有Docker镜像仓库。Docker主要用于管理各个节点上的容器。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:38 "},"article/Rancher/Chapter1/1-2-2-kubernetes.html":{"url":"article/Rancher/Chapter1/1-2-2-kubernetes.html","title":"1.2.2 Kubernetes简述","keywords":"","body":"1.2.2、Kubernetes简述 Kubernetes已成为容器集群管理标准，通过YAML文件来管理配置应用程序容器和其他资源。Kubernetes执行诸如调度，扩展，服务发现，健康检查，密文管理和配置管理等功能。 一个Kubernetes集群由多个节点组成: etcd database 通常在一个节点上运行一个etcd实例服务，但生产环境上，建议通过3个或5个(奇数)以上的节点来创建ETCD HA配置。 Master nodes 主节点是无状态的，用于运行API Server，调度服务和控制器服务。 Worker nodes 工作负载在工作节点上运行。 默认情况下Master节点也会有工作负载调度上去， 可通过命令设置其不加入调度 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:38 "},"article/Rancher/Chapter1/1-2-3-rancher.html":{"url":"article/Rancher/Chapter1/1-2-3-rancher.html","title":"1.2.3 Rancher架构","keywords":"","body":"1.2.3、Rancher架构 大多数Rancher2.0软件运行在Rancher Server节点上,Rancher Server包括用于管理整个Rancher部署的所有组件。 下图说明了Rancher2.0的\b运行架构。该图描绘了管理两个Kubernetes集群的Rancher server安装:一个由RKE创建，另一个由GKE创建。 Rancher API服务器 Rancher API server建立在嵌入式Kubernetes API服务器和etcd数据库之上。它实现了以下功能: Rancher API服务器 Rancher API server管理与外部身份验证提供程序(如Active Directory或GitHub)对应的用户身份 认证授权 Rancher API server管理访问控制和安全策略 项目 项目是集群中的一组多个命名空间和访问控制策略的集合 节点 Rancher API server跟踪所有集群中所有节点的标识。 集群控制和Agent 集群控制器和集群代理实现管理Kubernetes集群所需的业务逻辑: 集群控制器实现Rancher安装所需的全局逻辑。它执行以下操作: 为集群和项目配置访问控制策略 通过调用以下方式配置集群: 所需的Docker machine驱动程序 像RKE和GKE这样的Kubernetes引擎 单独的集群代理实例实现相应集群所需的逻辑。它执行以下活动: 工作负载管理，例如每个集群中的pod创建和部署 绑定并应用每个集群全局策略中定义的角色 集群与Rancher Server之间的通信:事件，统计信息，节点信息和运行状况 认证代理 该认证代理转发所有Kubernetes API调用。它集成了身份验证服务，如本地身份验证，Active Directory和GitHub。在每个Kubernetes API调用中，身份验证代理会对调用方进行身份验证，并在将调用转发给Kubernetes主服务器之前设置正确的Kubernetes模拟标头。Rancher使用服务帐户与Kubernetes集群通信。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:38 "},"article/Rancher/Chapter2/2-1-global.html":{"url":"article/Rancher/Chapter2/2-1-global.html","title":"2.1 全局层","keywords":"","body":"2.1、全局层 全局层主要对Rancher Server\b自身的基础配置,比如Rancher Server URL、登录认证等。 集群 全局层的集群菜单，用于列出集群中所有的K8S集群。 主机驱动 用于与三方云平台API对接的中间件程序。 应用商店-全局 \b全局层的应用商店，负责应用商店的开关与添加。 用户 添加或者删除用户，或者修改用户的权限。 系统设置 全局下系统的基础配置，比如系统默认镜像仓库。 安全 角色 一组权限的集合 Pod安全策略 Pod安全设置 登录认证 用户的登录访问认证 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter2/2-2-colony.html":{"url":"article/Rancher/Chapter2/2-2-colony.html","title":"2.2 集群层","keywords":"","body":"2.2、集群层 集群 显示当前集群的资源配置情况，各系统组件的健康状态；2.2之前，集群仪表盘显示当前集群的资源预留状态(并非实际资源使用)； 主机 当前集群中添加的所有主机 存储 存储类 持久卷 项目与命名空间 此集群\b拥有的项目和命名空间 集群成员 工具 告警 通知 日志 CI/CD powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter2/2-3-project.html":{"url":"article/Rancher/Chapter2/2-3-project.html","title":"2.3 项目层","keywords":"","body":"2.3、项目层 工作负载 工作负载服务 负载均衡 服务发现 数据卷 CI/CD 应用商店-项目 资源 告警 证书 配置映射 日志收集 镜像库 密文 命名空间 \b项目成员 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter2/2-4-other.html":{"url":"article/Rancher/Chapter2/2-4-other.html","title":"2.4 其他","keywords":"","body":"2.4、其他 API Keys 主机模板 喜好设定 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter3/3-1-k8s.html":{"url":"article/Rancher/Chapter3/3-1-k8s.html","title":"3.1 K8S集群管理","keywords":"","body":"3.1、K8S集群管理 多集群管理 容器平台能同时对多个Kubernetes集群进行管理，包括创建集群、删除集群、集群搜索、为集群添加主机等。每个集群有自己独立的管理视图，包括控制面板、主机视图、容器视图、应用视图，可图形化显示其所包含的节点状态和容器运行状态，并可以对节点和容器操作。每个集群上运行的应用和其他集群隔离。 集群基础设施管理和部署 容器云平台能够指定Kubernetes集群的部署角色，包括etcd数据节点、API Server、Controller Manager控制节点、worker计算节点等。不同集群能够指定不同的容器网络模式，灵活支持目前社区主流的容器网络解决方案，包括flannel、Calico、Canal等。平台能够提供自动化部署工具，快速灵活的部署kubernetes集群。 集群管理权限设定 可设定每个集群的用户角色和权限，除默认内置角色外，支持在图形界面进行细粒度的RBAC权限自定义和角色创建。管理员可以创建自定义角色，指定对平台内各种资源对象（包括但不限于Cluster、Pod、Deployment、ConfigMap等）的创建、删除、编辑、枚举等各种细粒度的操作权限。 导入外部Kubernetes集群管理 容器云平台必须能够导入外部Kubernetes集群并进行管理的功能，以满足对各种Kubernetes集群统一纳管的需求。导入的Kubernetes集群能够通过容器云平台界面进行统一的角色管理，应用部署等各种操作。 Kubernetes多版本支持 支持Kubernetes目前的主要稳定开源版本，包括1.9、1.10、1.11、1.12。用户在部署Kubernetes集群时可以根据需要选择相应的版本进行部署。 集群升级 通过平台创建的Kubernetes集群，集群的系统软件，如Kubernetes版本、网络等系统服务软件，可通过图形界面在线升级或回退，不影响集群环境中业务的使用。 Windows 集群支持 可管理 Windows Kubernetes 集群主机。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:40 "},"article/Rancher/Chapter3/3-2-tenant.html":{"url":"article/Rancher/Chapter3/3-2-tenant.html","title":"3.2 多租户功能","keywords":"","body":"3.2、多租户功能 基于独立集群的多租户支持 容器云平台支持基于独立集群的多租户隔离，可以为不同租户创建并使用独立的Kubernetes集群。各集群可以按需配置独立的管理员、用户及自定义角色，彼此之间完全隔离。 基于共享集群的多租户支持 容器云平台应支持集群内部的多租户隔离，集群内租户支持设置管理员、用户及自定义RBAC角色，以满足权限管理需求。当基于单个集群实现多租户隔离时，同一个集群内部的租户应用彼此隔离，单个租户内部的用户仅能查看和管理自己租户内部的应用，且不同租户应用容器之间需要实现网络隔离。 租户权限管理 支持租户内用户角色的管理和设置，支持RBAC自定义创建租户内用户角色和权限，以实现灵活的权限管理。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:40 "},"article/Rancher/Chapter3/3-3-dockerhost.html":{"url":"article/Rancher/Chapter3/3-3-dockerhost.html","title":"3.3 容器主机管理","keywords":"","body":"3.3、容器主机管理 纳管虚拟机 支持以图形界面在线添加虚拟机主机，新的主机被添加成功后将会显示活动状态，并可在图形界查看主机的具体配置信息，包括但不限于主机名，IP地址，docker引擎版本号，操作系统版本，CPU/内存/磁盘配置信息等。 纳管物理机 支持以图形界面在线添加物理机主机，新的主机被添加成功后将会显示活动状态，并可在图形界面看到主机的具体配置信息，包括但不限于主机名，IP地址，docker引擎版本号，操作系统版本，CPU/内存/磁盘配置信息等。 内置Docker Machine驱动管理 内置Docker Machine驱动，可以对各类Docker的machine drivers进行配置和管理，方便用户对接各类云平台、vSphere环境、OpenStack环境等。 主机分组管理 支持对不同的主机进行分组管理，可以使用标签（或类似方式）标识，如按物理区域、安全区域、组织架构、项目、应用划分打标签逻辑分组，支持多标签。 查看主机性能状态信息 系统提供便捷的图形化界面，以实现对容器主机相关性能和状态信息的监控和查看。可以查看的主机性能信息包括，CPU、内存、网络和磁盘，容器分配情况、端口使用情况、标签、存储等关键信息。 驱散容器功能 在对主机进行维护时，例如升级内核，硬件维护等，这个功能首先会禁止新的容器调度到这个节点，然后会对该节点上的容器有规则的进行驱散。完成主机维护后，可以恢复节点功能。 容器主机故障自动检测和自动应用漂移 当某个主机故障时，无法和管理节点时间正常通信时，则该主机将被表示为不可用状态，并在图形界面显示。该状态下管理节点将视图重连该主机，同时会将该主机上运行的容器自动漂移到其他正常主机节点，以保证该情况下相关容器的服务访问正常。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter3/3-4-dispatch.html":{"url":"article/Rancher/Chapter3/3-4-dispatch.html","title":"3.4 容器调度与管理","keywords":"","body":"3.4、容器调度与管理 容器生命周期管理 平台提供便捷操作容器服务图形化界面，可以编辑容器信息，可以启动、重启、停止、删除、克隆容器。 并可在图形界面上展示容器的信息和运行状态，包括健康状态，容器名、IP地址、所在主机、镜像和命令等 查看容器状态和性能 管理平台可以通过图形界面查看容器关键性能和配置信息，可以查看标签、存储卷、端口映射、实时监控信等关键信息，包括但不限于: CPU、内存、网络和磁盘、容器IP、Image、所使用主机等情况。 容器控制台 图形化界面可以直接调出该容器控制台，管理界面可以操作容器的CLI，方便后台控制人员执行命令行操作容器。 查看容器日志 管理平台图形化界面可以直接展示容器日志信息，并实时刷新。 指定容器运行的主机 支持标签或其它方式唯一限定容器运行主机。系统提供图形化界面，设置容器编排调度规则。支持亲和性/反亲和性容器调度设置，系统提供图形化界面，设置容器编排调度规则，支持基于标签的亲和性/反亲和性调度，支持全部满足/部分等过滤条件。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:40 "},"article/Rancher/Chapter3/3-5-dockerapp.html":{"url":"article/Rancher/Chapter3/3-5-dockerapp.html","title":"3.5 容器应用管理","keywords":"","body":"3.5、容器应用管理 容器应用堆栈管理 支持使用应用模板一键创建容器应用栈。可以从应用集合，服务集合的角度对容器进行集中的管理和配置。 应用管理视图 支持以不同方式查看、展现应用容器。至少支持根据命令空间Namespace、应用分类、容器运行节点、列表等方式展示容器列表。 通过上传编排文件直接部署应用 支持通过上yaml编排 文件，一键部署和启动应用。极大提高部署效率，降低部署难度和时间。 查看、下载编排配置文件 支持实时查看kubernetes编排文件配置内容。支持下载和保存kubernetes编排文件，方便配置编辑、保存、重新部署和故障恢复。 统一调用非容器化服务或系统 管理平台可方便的实现容器访问外部的应用和服务，容器可以访问如不适合进行容器化的大型应用（如MySQL/Oracle数据库）。支持通过图形界面创建相应的服务发现记录，包括外部IP地址、外部主机名、DNS别名等多种方法 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:40 "},"article/Rancher/Chapter3/3-6-docker.html":{"url":"article/Rancher/Chapter3/3-6-docker.html","title":"3.6 容器管理","keywords":"","body":"3.6、容器管理 项目管理功能 项目是一个或多个 namespace 集合，集群管理员和项目管理员可以从项目层级设置配额。可以配置该项目的CPU，内存，存储，Pod数量等等的配额。同时，在每个项目里，管理员也可以对每个namespace的配额进行控制。 容器服务健康检查 系统内置对容器服务的健康检查功能，支持在图形界面进行以下健康检查设置，包括: 可以设定基于HTTP的健康检查。 可以设定基于TCP的健康检查。 可以设定基于命令行命令的健康检查。 可以设定健康检查的颗粒度，如检查次数、间隔、超时时间等。 支持通过图形界面对容器设置不同的Liveness Check和Readniess check规则。 容器服务伸缩 提供图形界面，可以便捷手动进行容器扩容和收缩。还提供容器基于CPU、内存等资源使用率状态数值触发的自动扩容缩容。 容器升级和回滚功能 提供图形界面，可以便捷实现容器的升级和回滚操作。部署应用时可以设置应用的升级策略，包括新旧容器启停顺序、批量大小、最小就绪时间等等。 支持灰度发布 可以实现灰度升级，升级过程中服务不中断。升级后，图形界面提供UI回滚到之前版本。当部署之前包括多个版本时，可提供多个版本进行回滚选择。 伴随容器服务 可以为主容器提供伴随容器服务，在进行复杂应用部署时，可以提供支持。支持通过图形界面创建伴随容器。 1、可以为主容器创建伴随容器。 2、伴随容器可以和主容器同时启动和同时关闭。 3、伴随容器可以和主容器共享容器数据卷和容器网络。 容器可用性保障机制 可以设定服务容器的需要保证的有效数量，当系统故障时，平台可保证有效的的容器数量。可以保证应用服务维持一定的容器数量，用来保证服务正常。服务故障时可以重新创建容器，保证服务正常 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter3/3-7-network.html":{"url":"article/Rancher/Chapter3/3-7-network.html","title":"3.7 容器网络管理","keywords":"","body":"3.7、容器网络管理 容器网络访问策略控制 容器网络支持多租户隔离和策略控制，同集群内部的不同租户可以实现网络的隔离和限制。 支持容器基本网络模式 支持容器共享主机网络方式，可以在管理界面上设置容器网络为主机共享网路模式，容器共享主机网络namespace，使用主机网卡进行容器内外部通信。 支持高级网络模式 支持多种网络模式，容器平台提供网络插件，实现对容器IP和容器网络的管理，支持容器网络IP的自定义和跨主机容器网络互访。至少同时支持Flannel/Calico、Canal主流网络技术。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:40 "},"article/Rancher/Chapter3/3-8-lb.html":{"url":"article/Rancher/Chapter3/3-8-lb.html","title":"3.8 负载均衡服务","keywords":"","body":"3.8、负载均衡服务 内置负载均衡服务 内置容器负载均衡服务。通过图形界面创建负载均衡，可以进行端口指定、服务指定、SSL证书、会话保持、自定义负载均衡配置、标签及调度等各项功能。 可定义负载均衡会话保持策略 内置负载均衡服务可以配置可以配置并使用基于cookie的会话保持功能。 支持SSL终结功能 内置负载均衡服务可以配置可以配置并使用基于HTTPS的SSL终结功能。 负载均衡后端支持 提供图形界面，负载均衡后端同时支持Kubernetes Service对象和Pod直连，以支持话保持设置。 支持高级访问路由功能 提供图形界面，可以配置负载均衡高级路由功能，实现根据URL头信息、Domain name、访问路径等不同实现七层信息的转发。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:40 "},"article/Rancher/Chapter3/3-9-storage.html":{"url":"article/Rancher/Chapter3/3-9-storage.html","title":"3.9 容器存储服务","keywords":"","body":"3.9、容器存储服务 存储类型支持 容器云平台应支持Kubernetes社区版本内置支持的所有存储类型，包括FC、iSCSI、Ceph、Cinder、GlusterFS、AzureDisk、AWS EBS、ScaleIO等等。 方案提供方应该能够提供自主产权且开源的分布式块存储方案，以满足业务上对持久化存储的要求 Persistent Volume支持 支持通过图形界面创建Persistent Volume，支持的类型包括上述所列Kubernetes标准版本内置的存储类型。用户可以通过图形界面方便的设置相关存储参数。PV创建后可以在应用部署时通过图形界面创建PVC使用。 Storage Class支持 支持通过图形界面创建Storage Class以满足存储动态自动创建需求，支持的类型包括上述所列Kubernetes标准版本内置的存储类型。用户可以通过图形界面方便的设置相关存储参数。Storage Class创建后可以在应用部署时通过图形界面使用。 超融合存储支持 提供超融合存储解决方案，支持基于容器集群宿主机本地磁盘构建存储池并与容器集群进行集成。容器可利用本集群内部的存储池实现数据的持久化和高可用。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter3/3-10-log.html":{"url":"article/Rancher/Chapter3/3-10-log.html","title":"3.10 系统监控及日志","keywords":"","body":"3.10、系统监控及日志 系统监控 支持集群和集群内部租户不同层级的监控设置，监控内容至少应包括: 系统组件健康状态，如etcd、API Server等 系统部署事件，如创建Deployment、Service对象等。 主机资源利用率，如CPU、内存等 应用可用状态，如Deployment中可用容器低于一定比例等。 系统告警 需要提供系统内建的告警系统 告警系统支持通过图形界面设置告警目标，不同告警规则可按需设置告警目标。告警目标应支持多种企业级集成，至少要同时支持对电子邮件、Slack、PageDuty系统的支持。同时需要提供 Webhook扩展方式，实现对其他告警方式的支持和扩展。 告警规则支持临时暂停、恢复，初始发送延迟、发送间隔等高级设置，以按需控制告警信息的发送。 系统日志 平台提供日志收集代理，支持自动收集容器和应用程序日志。 日志系统能够在集群层面、项目层面分别对应不同的日志平台，以满足用户部门对日志功能使用的灵活性，以满足不同应用场景需求。 日志平台集成 日志代理应支持业内主流日志平台集成，可以同时支持对ElasticSearch、Kafka、Splunk和Syslog的对接，用户在图形界面即可设置与上述平台的自动化集成对接。 日志系统能够在集群层面、项目层面分别对应不同的日志平台，以满足用户部门对日志功能使用的灵活性 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter3/3-11-appstore.html":{"url":"article/Rancher/Chapter3/3-11-appstore.html","title":"3.11 应用商店管理","keywords":"","body":"3.11、应用商店管理 容器应用商店 容器平台支持容器化应用商店，实现容器应用的模板化展示和快速部署。应用商店应支持Kubernetes社区的Helm Charts模板。 企业级应用商店展示、组织及管理 提供图形界面，可以查看应用商店、实现应用模板的组织和管理。支持搜索和分类选择展示。 支持用户交互的参数配置 在应用商店配置页面中可配置模板版本和自定义参数，在配置过程中可以通过界面进行自定义配置。在启动应用过程中，进行交互的参数可以自定义。同时不同的应用可以定义不同的参数。支持在应用商店模板中定义参数的类型、提示信息、默认值等相关设置，应用部署展示UI可根据参数定义动态生成并展示相关页面。 支持应用发布版本管理 可以在应用商店中选择应用的不同发布版本，并启动运行。应用商店出现该应用的新版本时，可自动提示正在运行的应用实例有新版本可以升级。 支持部署私有隔离的应用商店 管理平台可以设置不同的应用商店路径。每个路径都可以指向一个独立的应用商店，可以设置多个应用商店，应用可以放在不同的应用商店中进行隔离管理。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter3/3-12-manager.html":{"url":"article/Rancher/Chapter3/3-12-manager.html","title":"3.12 系统管理及安全","keywords":"","body":"3.12、系统管理及安全 认证方式 容器云平台支持多种认证集成方式，除本地认证外，需支持主流的认证系统如微软活动目录、OpenLDAP、Github、Keycloak等，支持自定义认证插件实现集成认证。 容器安全策略 容器云平台支持设置容器安全策略，对创建的容器进行安全管控，例如限制启动特权容器、限制容器使用主机IPC模式、主机网络模式，限制容器可以映射的主机数据卷路径等。容器安全策略应当支持绑定到特定集群和集群内部的多租户隔离实现。 API秘钥管理 容器云平台支持为不同用户创建独立的API秘钥，API秘钥仅当首次创建时可查看。且支持进行API秘钥自动过期设置，以确保系统安全。 配置映射 提供图形化界面，配置configmap以供服务调用。 密文管理 提供图形化界面，配置secret以供服务调用。 证书管理 平台提供图形界面，可以对SSL证书进行管理。包括导入证书、删除证书等。证书可用于应用访问SSL加密。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter3/3-13-image.html":{"url":"article/Rancher/Chapter3/3-13-image.html","title":"3.13 镜像库功能","keywords":"","body":"3.13、镜像库功能 对接外部私有镜像仓库 提供图形界面，设置连接外部的镜像仓库，可设置外部仓库的认证信息实现认证集成。可以设置默认镜像库，设置镜像库白名单等。 项目管理 支持公有和私有项目类型: 公有: 公有项目中的镜像所有用户均有下载权限； 私有: 私有项目中的镜像只有项目内的成员有相应的操作权限； 新建项目 每当新建一个用户时，系统都会默认创建一个以该用户的用户名为项目名称的私有项目；系统管理员可以创建新的项目，项目详情页，可查看镜像和访问控制列表。 搜索项目 支持输入关键字进行项目搜索； 镜像生命周期管理 镜像生命生命周期主要功能如下所示: 镜像下载: 若镜像为私有镜像，用户至少要获得对应项目的下载权限才能成功下载镜像； 镜像上传: 用户首先要拥有对应项目的提交权限才能在该项目下上传镜像； 镜像修改: 用户可以修改镜像的描述信息，以及dockerfile； 镜像复制: 实现镜像在不同项目间的复制，用户至少必须同时拥有源项目与目标项目的提交权限； 镜像删除: 在镜像列表可以选择删除镜像的某个版本，也可以直接删除整个镜像。 异地镜像仓库同步 支持设置好同步关系，并且多镜像仓库之间镜像自动同步。镜像同步的最小颗粒度是容器项目。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter3/3-14-system.html":{"url":"article/Rancher/Chapter3/3-14-system.html","title":"3.14 系统集成支持","keywords":"","body":"3.14、系统集成支持 支持通过纯命令行方式进行配置和管理 容器平台提供命令行管理工具，可以通过命令行对容器管理平台进行配置和管理。 方便运维人员开发自动化运维脚本。 提供API接口 容器云平台应支持Restful API调用，以方便的与内部系统进行集成。API接口需求如下: 支持页面直接展现API调用内容 所有页面上的操作都能通过API支持 支持基于多租户API调用的访问授权。 针对不同的用户，都可以生成Access key和Secret key秘钥对，在获取正确的秘钥对后方能对API接口进行访问。 容器操作系统 容器云厂商在提供容器平台的同时，还拥有知名的自主品牌的容器化操作系统平台，以实现容器宿主机的快速创建和部署，降低系统资源消耗和受攻击面。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter3/3-15-cicd.html":{"url":"article/Rancher/Chapter3/3-15-cicd.html","title":"3.15 CI/CD功能","keywords":"","body":"3.15、CI/CD功能 同时支持多源码管理 CI/CD支持公有Github、Gitlab和私有Gitlab代码库的对接。 自动部署镜像 打通了从代码提交，自动测试，自动构建镜像，自动部署镜像的全流程。 与应用商店集成 打通与应用商店的集成，可根据CI/CD的产物动态更新应用商店中的配置文件，应用商店提示有更新可用。 灵活的流程控制 可以在最初的设置阶段配置符合某既定要求的表达式或标签，而系统会在执行阶段根据执行情况自动跳过不符合该表达式或标签的阶段或步骤。如此一来，不同的代码分支可以自动匹配不同的CI流程，从而支持较为复杂的流程控制。 powered by Gitbook该文件最后修改时间： 2020-04-01 10:24:39 "},"article/Rancher/Chapter4/4-1-base.html":{"url":"article/Rancher/Chapter4/4-1-base.html","title":"4.1 入门须知","keywords":"","body":"4.1、入门须知 熟悉Linux基础命令； 了解SSH使用方法，了解公钥/私钥工作原理； 熟悉Docker基本使用方法及基础命令，比如：容器日志查看； 了解SSL证书使用方法； 了解负载均衡工作原理(L4/L7)； 了解域名解析原理； 了解K8S基本概念 powered by Gitbook该文件最后修改时间： 2020-04-01 15:59:42 "},"article/Rancher/Chapter4/4-2-1-system.html":{"url":"article/Rancher/Chapter4/4-2-1-system.html","title":"4.2.1 系统需求","keywords":"","body":"4.2.1、系统需求 Ubuntu 16.04 +(64位) Centos/RedHat Linux 7.5+(64位) RancherOS 1.3.0+(64位) powered by Gitbook该文件最后修改时间： 2020-04-01 15:59:42 "},"article/Rancher/Chapter4/4-2-2-handware.html":{"url":"article/Rancher/Chapter4/4-2-2-handware.html","title":"4.2.2 硬件需求","keywords":"","body":"4.2.2、硬件需求 CPU: 2C 内存: 4GB > 注意: 此配置仅为满足小规模测试环境的最低配置。如用于生产，请参考基础配置要求。 powered by Gitbook该文件最后修改时间： 2020-04-01 15:59:42 "},"article/Rancher/Chapter4/4-2-3-software.html":{"url":"article/Rancher/Chapter4/4-2-3-software.html","title":"4.2.3 软件需求","keywords":"","body":"4.2.3、软件需求 软件: Docker 支持的Docker版本: 1.12.6 1.13.1 17.03.2 powered by Gitbook该文件最后修改时间： 2020-04-01 15:59:42 "},"article/Rancher/Chapter4/4-3-install.html":{"url":"article/Rancher/Chapter4/4-3-install.html","title":"4.3 安装Rancher","keywords":"","body":"4.3、安装Rancher 1、主机名配置 因为K8S的规定，主机名只支持包含 - 和 .(中横线和点)两种特殊符号，并且主机名不能出现重复。 2、Hosts 配置每台主机的hosts(/etc/hosts),添加host_ip $hostname到/etc/hosts文件中。 3、关闭SELinux sudo sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config 4、关闭防火墙 CentOS systemctl stop firewalld.service && systemctl disable firewalld.service Ubuntu ufw disable 5、配置主机时间、时区、系统语言 查看时区 date -R 或者 timedatectl 修改时区 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 修改系统语言环境 sudo echo 'LANG=\"en_US.UTF-8\"' >> /etc/profile;source /etc/profile 6、Kernel性能调优 cat >> /etc/sysctl.conf 最后执行保存配置 sysctl -p 7、ETCD集群容错表 建议在ETCD集群中使用奇数个成员,通过添加额外成员可以获得更高的失败容错。 集群大小 MAJORITY 失败容错 1 1 0 2 2 0 3 2 1 4 3 1 5 3 2 6 4 2 7 4 3 8 5 3 9 5 4 8、Docker安装 参考Docker安装 9、安装Rancher 要想在主机上安装Rancher,需要先登录到主机上，接着进行以下步骤: 通过shell工具(例如PuTTy或远程终端连接)登录到主机 docker run -d --restart=unless-stopped -p 80:80 -p 443:443 -v /data/rancher:/var/lib/rancher/ -v /root/var/log/auditlog:/var/log/auditlog -e CATTLE_SYSTEM_CATALOG=bundled -e AUDIT_LEVEL=3 rancher/rancher:stable powered by Gitbook该文件最后修改时间： 2020-04-02 10:37:55 "},"article/Rancher/Chapter4/4-4-login.html":{"url":"article/Rancher/Chapter4/4-4-login.html","title":"4.4 登陆Rancher","keywords":"","body":"4.4、登陆Rancher 登录并开始使用Rancher。登录后，你将进行一些一次性配置。 访问 https://IP powered by Gitbook该文件最后修改时间： 2020-04-01 15:59:42 "},"article/Rancher/Chapter4/4-5-createk8s.html":{"url":"article/Rancher/Chapter4/4-5-createk8s.html","title":"4.5 创建K8S集群","keywords":"","body":"4.5、创建K8S集群 现在创建第一个Kubernetes集群，可以使用自定义选项。你可以添加云主机、内部虚拟机或物理主机作为集群节点，节点可以运行任何一种或多种主流Linux发行版: 1、在全局视图下，点击菜单中的集群 , 并点击添加集群； 2、选择自定义，并设置集群名称,其他参数可不用修改，点击下一步； 3、选择节点运行的角色 默认会勾选Worker角色，根据需要可以一次勾选多种角色。比如，假设我只有一个节点，那就需要把所有角色都选择上，选择后上面的命令行会自动添加相应的命令参数 4、其他参数保持默认，点击命令行右侧的复制按钮，复制命令参数，如果是多台主机，根据角色的不同，需要复制多次。 5、登录预添加集群的主机，执行以上复制的命令； 6、在主机上执行完命令后，最后点击完成； 7、回到全局视图，可以查看集群的部署状态； 8、集群创建完成 powered by Gitbook该文件最后修改时间： 2020-04-01 15:59:42 "},"article/Rancher/Chapter4/4-6-deploy.html":{"url":"article/Rancher/Chapter4/4-6-deploy.html","title":"4.6 部署工作负载","keywords":"","body":"4.6、部署工作负载 工作负载是一个对象，包括pod以及部署应用程序所需的其他文件和信息。我们以nginx作为例如: 1、在Default视图下，点击工作负载—部署服务 2、在部署工作负载页面，设置工作负载名称、副本数量、镜像名称、命名空间、端口映射，其他参数保持默认，最后点击启动。 3、部署完成 4、通过31174端口去访问nginx服务 powered by Gitbook该文件最后修改时间： 2020-04-01 15:59:42 "},"article/Rancher/Chapter5/5-1-django.html":{"url":"article/Rancher/Chapter5/5-1-django.html","title":"5.1 基于 Rancher 运行 Django 程序","keywords":"","body":"基于 Rancher 运行 Django 程序 DEMO地址 https://github.com/honest1y/demo-backend Dockerfile FROM python:latest ENV BASE_ROOT=\"/data\" WORKDIR /data ADD . ${BASE_ROOT} RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo 'Asia/Shanghai' >/etc/timezone RUN pip config set global.index-url http://mirrors.aliyun.com/pypi/simple && pip config set install.trusted-host mirrors.aliyun.com RUN pip install --upgrade pip && pip install --default-timeout=100 -r ${BASE_ROOT}/requirements.txt \\ && chmod +x ${BASE_ROOT}/entrypoint.sh && ln -s ${BASE_ROOT}/entrypoint.sh /bin/entrypoint.sh EXPOSE 8000/tcp ENTRYPOINT [\"./entrypoint.sh\"] 1、拉取代码 git clone https://github.com/honest1y/demo-backend.git 2、构建镜像 cd demo-backend docker build -t registry.cn-shanghai.aliyuncs.com/cloud-devops/demo-backendend:v1 . registry.cn-shanghai.aliyuncs.com 为阿里云容器镜像服务，即私有化仓库 3、推送镜像 docker push registry.cn-shanghai.aliyuncs.com/cloud-devops/demo-backendend:v1 4、Rancher配置 1、点击 “资源” -> \"密文\" -> \"镜像库凭证列表\"，添加凭证，填写镜像仓库相关信息 2、点击“资源” -> “工作负载”，部署服务 5、访问测试 powered by Gitbook该文件最后修改时间： 2020-04-02 14:23:43 "},"article/Rancher/Chapter5/5-2-vue.html":{"url":"article/Rancher/Chapter5/5-2-vue.html","title":"5.2 基于 Rancher 运行 VUE 程序","keywords":"","body":"基于 Rancher 运行 VUE 程序 DEMO地址 https://github.com/honest1y/demo-frontend Dockerfile FROM node:10 as demo-frontend-build COPY ./ /demo-frontend WORKDIR /demo-frontend RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo 'Asia/Shanghai' >/etc/timezone RUN npm install -g cnpm --registry=https://registry.npm.taobao.org && cnpm install && npm run build FROM nginx:latest RUN mkdir /demo-frontend-html RUN rm -fr /etc/nginx/conf.d/default.conf COPY --from=demo-frontend-build /demo-frontend/dist /demo-frontend-html COPY demo-frontend.conf /etc/nginx/conf.d demo-frontend.conf server { listen 80; server_name localhost; location / { index index.html; root /demo-frontend-html; try_files $uri $uri/ /index.html; client_body_buffer_size 200m; charset utf-8; } gzip on; gzip_vary on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_comp_level 6; gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png image/x-icon; } 1、拉取代码 git clone https://github.com/honest1y/demo-frontend.git 2、构建镜像 docker build -t registry.cn-shanghai.aliyuncs.com/cloud-devops/demo-frontend:v1 . registry.cn-shanghai.aliyuncs.com 为阿里云容器镜像服务，即私有化仓库 3、推送镜像 docker push registry.cn-shanghai.aliyuncs.com/cloud-devops/demo-frontend:v1 4、Rancher配置 1、点击 “资源” -> \"密文\" -> \"镜像库凭证列表\"，添加凭证，填写镜像仓库相关信息 2、点击“资源” -> “工作负载”，部署服务 5、访问测试 powered by Gitbook该文件最后修改时间： 2020-04-02 14:23:43 "},"article/Rancher/document.html":{"url":"article/Rancher/document.html","title":"6、参考文档","keywords":"","body":"参考文档 Rancher 2.x Docs powered by Gitbook该文件最后修改时间： 2020-04-01 16:36:40 "},"article/Kubernetes/Chapter1/1-Introduction.html":{"url":"article/Kubernetes/Chapter1/1-Introduction.html","title":"1.1 什么是Kubernetes?","keywords":"","body":"什么是Kubernetes? sadasdas powered by Gitbook该文件最后修改时间： 2020-03-05 19:22:04 "},"article/Kubernetes/Chapter1/2-Whykubernetes.html":{"url":"article/Kubernetes/Chapter1/2-Whykubernetes.html","title":"1.2 为什么要用Kubernetes","keywords":"","body":"为什么要用Kubernetes? powered by Gitbook该文件最后修改时间： 2020-03-05 19:08:49 "},"article/Kubernetes/Chapter1/3-Guestbook.html":{"url":"article/Kubernetes/Chapter1/3-Guestbook.html","title":"1.3 GuestBook举例","keywords":"","body":"GuestBook 典型的Hello World例子是在屏幕终端输出一句话“Hello World”，而这里的Hello World例子是一个Web留言板应用，并且是一个基于PHP+Redis的两层分布书架构的应用，前端PHP Web网站通过访问后端Redis数据库来完成用户留言的查询和添加等功能，更重要的是这个传统的经典案例部署在Kubernetes集群中，具备Redis读写分离能力。 留言板页面很简单，如图所示，首页将显示访客的留言，留言内容是从Redis中查询得到的，首页提供一个文本输入框允许访客添加留言，添加的留言将被写入Redis中。 留言板的系统部署架构如图，为了实现读写分离，在Redis层采用了一个Master与两个Slave的高可用集群模式进行部署，其中Master实例用于前端写操作（添加留言），而两个Slave实例则用于前端读操作（读取留言），PHP的Web层同样启动3个实例组成集群，实现客户端对网站访问的负载均衡。 redis-master： 用于前端Web应用进行“写”留言的操作，其中已经保存了一条内容为“Hello World”的留言。 guestbook-redis-slave：用于前端Web应用进行“读”留言的操作，并与 redis-master 的数据保持同步 guestbook-php-frontend：PHP Web服务，在网页上展示留言内容，也提供一个文本输入框供访客添加留言。 powered by Gitbook该文件最后修改时间： 2020-03-06 11:03:12 "},"article/Kubernetes/Chapter1/3-1-redis-master.html":{"url":"article/Kubernetes/Chapter1/3-1-redis-master.html","title":"1.3.1 创建redis-master Pod和服务","keywords":"","body":"创建 Redis-master Pod和服务 首先为 redis-master 服务创建一个名为 redis-master 的RC定义文件：redis-master.yaml apiVersion: v1 kind: ReplicationController metadata: name: redis-master labels: name: redis-master spec: replicas: 1 selector: name: redis-master template: metadata: labels: name: redis-master spec: containers: - name: master image: kubeguide/redis-master ports: - containerPort: 6379 其中，kind字段的值为“ReplicationController”，表示这是一个RC；spec.selector是RC的Pod选择器，即监控和管理拥有这些标签（Label）的Pod实例，确保当前集群上始终有且仅有 replicas 个 Pod 实例在运行，这里我们设置 replicas=1，表示只能运行一个名为redis-master的Pod实例，当集群中运行的Pod数量小于replicas时，RC会根据 spec.template段定义的Pod模版来生成一个新的Pod实例，labels属性指定了该Pod的标签，注意，这里的labels必须匹配RC的 spec.selector，否则此 RC 就会陷入 “只为他人做嫁衣”的悲惨世界中，永无翻身之时。 创建好后，可以在 Master 节点执行命令：kubectl create -f redis-master.yaml，将它发布到集群中，就完成了 redis-master 的创建过程。 [root@rancher-0 ~]# kubectl create -f redis-master.yaml replicationcontroller/redis-master created [root@rancher-0 ~]# kubectl get rc NAME DESIRED CURRENT READY AGE redis-master 1 1 1 25s 接下来运行 kubectl get pods命令来查看当前系统中的Pod列表信息，我们看到一个名为redis-master-xxx的Pod实例，这是Kubernetes根据redis-master这个RC定义自动创建的Pod。由于Pod调度和创建需要花费一定的时间，比如需要一定的时间来确定调度到哪个节点上，以及下载Pod的相关镜像，所以一开始我们看到Pod状态为Pending。当Pod成功创建完成以后，状态会更新为 Running。 [root@rancher-0 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE redis-master-xtsdr 1/1 Running 0 2m44s 提供Redis服务的Pod已经创建好了，接下来创建一个与之关联的Service（服务），redis-master的定义文件名为：redis-master-svc.yaml，内容如下： apiVersion: v1 kind: Service metadata: name: redis-master labels: name: redis-master spec: ports: - port: 6379 targetPort: 6379 selector: name: redis-master 其中 metadata.name 是 Service 的服务名（ServiceName），spec.selector 确定了哪些Pod对应到本服务，这里的定义表明拥有 redis-master 标签的 Pod 属于 redis-master 服务。另外，ports部分中的 targetPort 属性用来确定提供该服务的容器所暴露（EXPOSE）的端口号，即具体的服务进程在容器内的 targetPort 上提供服务，而 port 属性则定义了 Service 的虚端口。 运行 kubectl，创建 Service： [root@rancher-0 ~]# kubectl create -f redis-master-svc.yaml service/redis-master created [root@rancher-0 ~]# kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.1.0.1 443/TCP 42h redis-master ClusterIP 10.1.43.109 6379/TCP 34s 注意到 redis-master 服务被分配了一个值为 10.1.43.109 的IP地址，随后，Kubernetes集群中其他创建的 Pod 就可以通过这个IP地址+端口6379来访问它了。 但由于IP地址是在服务创建后由Kubernetes系统自动分配的，在其他Pod中无法预先知道某个Service的虚拟IP地址，因此需要一个机制来找到这个服务。为此，Kubernetes使用了Linux环境变量，在每个Pod的容器里都增加了一组Service相关的环境变量，用来记录从服务名到虚拟IP地址的映射关系。以 redis-master 为例，在容器中的环境变量会增加下面两条记录： REDIS_MASTER_SERVICE_HOST=10.1.43.109 REDIS_MASTER_SERVICE_PORT=6379 于是，redis-slave 和 frontend 等 Pod 中的应用程序就可以通过环境变量 REDIS_MASTER_SERVICE_HOST 得到 redis-master 服务的虚拟IP地址，通过环境变量 REDIS_MASTER_SERVICE_PORT得到 redis-master 服务的端口号，完成了对服务地址的查询功能。 powered by Gitbook该文件最后修改时间： 2020-03-06 15:11:00 "},"article/Kubernetes/Chapter1/3-2-redis-slave.html":{"url":"article/Kubernetes/Chapter1/3-2-redis-slave.html","title":"1.3.2 创建redis-slave Pod和服务","keywords":"","body":"创建 redis-slave Pod和服务 接下来我们继续完成 redis-slave 服务的创建过程，在本次实验中， redis-slave 会启动两个副本，每个副本的 Redis 进程都与redis-master所对应的Redis进程进行数据同步，3个Redis实例组成了一个具备读写分离能力的Redis集群。 留言板的PHP程序通过访问 redis-slave 服务来获取已保存的留言数据。与之前的 redis-master 服务的创建过程一样，首先创建一个名为 redis-slave 的RC定义文件： apiVersion: v1 kind: ReplicationController metadata: name: redis-slave labels: name: redis-slave spec: replicas: 2 selector: name: redis-slave template: metadata: labels: name: redis-slave spec: containers: - name: master image: kubeguide/guestbook-redis-slave env: - name: GET_HOSTS_FROM value: env ports: - containerPort: 6379 运行 kubectl create 命令： [root@rancher-0 ~]# kubectl create -f redis-slave.yaml replicationcontroller/redis-slave created 运行 kubectl get 命令查看 RC： [root@rancher-0 ~]# kubectl get rc NAME DESIRED CURRENT READY AGE redis-master 1 1 1 4h19m redis-slave 2 2 2 27s 运行 kubectl get 命令查看 Pod： [root@rancher-0 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE redis-master-xtsdr 1/1 Running 0 4h19m redis-slave-g7dvv 1/1 Running 0 47s redis-slave-pk5g8 1/1 Running 0 47s 然后创建 redis-slave 服务，内容如下： apiVersion: v1 kind: Service metadata: name: redis-slave labels: name: redis-slave spec: ports: - port: 6379 selector: name: redis-slave 运行 kubectl 创建 Service： [root@rancher-0 ~]# kubectl create -f redis-slave-svc.yaml service/redis-slave created 运行 kubectl get 查看创建的 Service： [root@rancher-0 ~]# kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.1.0.1 443/TCP 47h redis-master ClusterIP 10.1.43.109 6379/TCP 4h14m redis-slave ClusterIP 10.1.197.43 6379/TCP 22s [root@rancher-0 ~]# powered by Gitbook该文件最后修改时间： 2020-03-06 15:00:50 "},"article/Kubernetes/Chapter1/3-3-frontend.html":{"url":"article/Kubernetes/Chapter1/3-3-frontend.html","title":"1.3.3 创建frontend Pod和服务","keywords":"","body":"创建 frontend Pod和服务 类似的，定义 frontend 的 RC 配置文件，内容如下： apiVersion: v1 kind: ReplicationController metadata: name: frontend labels: name: frontend spec: replicas: 3 selector: name: frontend template: metadata: labels: name: frontend spec: containers: - name: frontend image: kubeguide/guestbook-php-frontend env: - name: GET_HOSTS_FROM value: env ports: - containerPort: 80 运行 kubectl create 命令创建 RC： [root@rancher-0 ~]# kubectl create -f frontend.yaml replicationcontroller/frontend created 查看已创建的 RC： [root@rancher-0 ~]# kubectl get rc NAME DESIRED CURRENT READY AGE frontend 3 3 1 19s redis-master 1 1 1 6h45m redis-slave 2 2 2 146m 再查看生成的 Pod： [root@rancher-0 ~]# kubectl get pods NAME READY STATUS RESTARTS AGE frontend-62n5t 1/1 Running 0 47s frontend-tk9tb 1/1 Running 0 47s frontend-zmbw6 1/1 Running 0 47s redis-master-xtsdr 1/1 Running 0 6h45m redis-slave-g7dvv 1/1 Running 0 147m redis-slave-pk5g8 1/1 Running 0 147m 最后创建 frontend Service， 主要目的是使用 Service 的 NodePort 给 Kubernetes 集群中的 Service 映射一个外网可以访问的端口，这样一来，外部网络就可以通过 NodeIP + NodePort的方式访问集群中的服务了。 服务定义文件如下： apiVersion: v1 kind: Service metadata: name: frontend labels: name: frontend spec: type: NodePort ports: - port: 80 nodePort: 30001 selector: name: frontend 这里的关键点是设置 type = NodePort，并指定一个 NodePort 的值，表示使用 Node 上的物理机端口提供对外访问的能力。需要注意的是， spec.ports.NodePort 的端口号定义有范围限制，默认为 30000 ~ 32767，如果配置为范围外的端口号，则创建 Service 失败。 运行 kubectl 创建 Service： [root@rancher-0 ~]# kubectl create -f frontend-svc.yaml service/frontend created 查看已创建的 Service： [root@rancher-0 ~]# kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE frontend NodePort 10.1.162.83 80:30001/TCP 23s kubernetes ClusterIP 10.1.0.1 443/TCP 2d1h redis-master ClusterIP 10.1.43.109 6379/TCP 6h42m redis-slave ClusterIP 10.1.197.43 6379/TCP 148m powered by Gitbook该文件最后修改时间： 2020-03-06 17:40:22 "},"article/Kubernetes/Chapter1/3-4-test.html":{"url":"article/Kubernetes/Chapter1/3-4-test.html","title":"1.3.4 通过浏览器访问网页","keywords":"","body":"powered by Gitbook该文件最后修改时间： 2020-03-05 19:01:01 "},"article/Kubernetes/Chapter2/1-Prepare.html":{"url":"article/Kubernetes/Chapter2/1-Prepare.html","title":"2.1 环境准备","keywords":"","body":"环境准备 Kubernetes支持在物理服务器或虚拟机中运行，本次使用虚拟机准备测试环境，硬件配置信息如表所示： IP地址 节点角色 CPU 内存 Hostname 172.20.2.10 master 4 4 master 172.20.2.11 node 4 4 node-1 172.20.2.12 node 4 4 node-2 172.20.2.13 node 4 4 node-3 1、设置主机名 设置主机名hostname，管理节点设置主机名为 master hostnamectl set-hostname master 需要设置其他主机名称时，可将 master 替换为正确的主机名node1、node2即可。 2、添加解析 编辑 /etc/hosts 文件，添加域名解析 cat >/etc/hosts 172.20.2.10 master 172.20.2.11 node-1 172.20.2.12 node-2 172.20.2.13 node-3 EOF 3、关闭防火墙、selinux和swap systemctl stop firewalld systemctl disable firewalld setenforce 0 sed -i \"s/^SELINUX=enforcing/SELINUX=disabled/g\" /etc/selinux/config swapoff -a sed -i 's/.*swap.*/#&/' /etc/fstab 4、配置内核参数，将桥接的IPv4流量传递到iptables的链 cat > /etc/sysctl.d/k8s.conf 5、配置国内yum源 yum install -y wget mkdir /etc/yum.repos.d/bak && mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos7_base.repo wget -O /etc/yum.repos.d/epel.repo http://mirrors.cloud.tencent.com/repo/epel-7.repo yum clean all && yum makecache 6、配置国内Kubernetes源 cat /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF 7、配置 docker 源 wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo powered by Gitbook该文件最后修改时间： 2020-03-05 18:47:00 "},"article/Kubernetes/Chapter2/2-Install.html":{"url":"article/Kubernetes/Chapter2/2-Install.html","title":"2.2 集群配置","keywords":"","body":"集群配置 1、安装docker yum install -y docker-ce-18.06.1.ce-3.el7 systemctl enable docker && systemctl start docker docker –version Docker version 18.06.1-ce, build e68fc7a 2、安装kubeadm yum install -y kubelet-1.14.3 kubeadm-1.14.3 kubectl-1.14.3 systemctl enable kubelet Kubelet负责与其他节点集群通信，并进行本节点Pod和容器生命周期的管理。Kubeadm是Kubernetes的自动化部署工具，降低了部署难度，提高效率。Kubectl是Kubernetes集群管理工具。 3、部署master 节点 3.1 集群初始化 kubeadm init --kubernetes-version=1.14.2 \\ --apiserver-advertise-address=172.20.2.10 \\ --image-repository registry.aliyuncs.com/google_containers \\ --service-cidr=10.1.0.0/16 \\ --pod-network-cidr=10.244.0.0/16 定义POD的网段为: 10.244.0.0/16， api server地址就是master本机IP地址。 这一步很关键，由于kubeadm 默认从官网k8s.grc.io下载所需镜像，国内无法访问，因此需要通过–image-repository指定阿里云镜像仓库地址，很多新手初次部署都卡在此环节无法进行后续配置。 集群初始化成功后返回如下信息： 记录生成的最后部分内容，此内容需要在其它节点加入Kubernetes集群时执行。 kubeadm join 172.20.2.10:6443 --token kekvgu.nw1n76h84f4camj6 \\ --discovery-token-ca-cert-hash sha256:4ee74205227c78ca62f2d641635afa4d50e6634acfaa8291f28582c7e3b0e30e 3.2 配置kubectl工具 mkdir -p /root/.kube cp /etc/kubernetes/admin.conf /root/.kube/config kubectl get nodes kubectl get cs 3.3 部署flannel网络 kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml 4、部署node节点 执行如下命令，使所有node节点加入Kubernetes集群 kubeadm join 172.20.2.10:6443 --token kekvgu.nw1n76h84f4camj6 \\ --discovery-token-ca-cert-hash sha256:4ee74205227c78ca62f2d641635afa4d50e6634acfaa8291f28582c7e3b0e30e 此命令为集群初始化时（kubeadm init）返回结果中的内容 5、集群状体检测 kubectl get nodes NAME STATUS ROLES AGE VERSION master Ready master 26m v1.14.2 node1 Ready 3m10s v1.14.2 node2 Ready 3m v1.14.2 node3 Ready 3m v1.14.2 powered by Gitbook该文件最后修改时间： 2020-03-05 18:49:10 "},"article/Shell/Chapter1/1-1-shell.html":{"url":"article/Shell/Chapter1/1-1-shell.html","title":"1、什么是Shell","keywords":"","body":"Shell是什么？ Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 Shell 脚本 shell脚本的基本概念是一个命令列表中列出的顺序执行。 我们将在接下来的几个教程写了许多脚本。这将是一个简单的文本文件，在其中，我们会把我们所有的命令和其他一些必要的结构，告诉shell环境做什么，什么时候做。 powered by Gitbook该文件最后修改时间： 2020-03-31 16:11:39 "}}